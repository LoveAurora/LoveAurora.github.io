<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>范德蒙行列式和范德蒙矩阵</title>
      <link href="post/5a8a6c8d.html"/>
      <url>post/5a8a6c8d.html</url>
      
        <content type="html"><![CDATA[<h1>范德蒙行列式和范德蒙矩阵</h1><p>一个 e 阶的范德蒙行列式由 e 个数 c₁，c₂，…，cₑ 决定，它的第 1 行全部都是 1，也可以认为是 c₁，c₂，…，cₑ 各个数的 0 次幂，它的第 2 行就是 c₁，c₂，…，cₑ（的一次幂），它的第 3 行是 c₁，c₂，…，cₑ 的二次幂，它的第 4 行是 c₁，c₂，…，cₑ 的三次幂，…，直到第 e 行是 c₁，c₂，…，cₑ 的 e-1 次幂。</p><h1>定义</h1><p>形如</p><p><img src="https://www.tangyulong.site/img/Math/Vandermonde/2.svg" alt="img"></p><p>的 n 阶行列式称为范德蒙行列式。</p><h3 id="范德蒙行列式的值"><a class="header-anchor" href="#范德蒙行列式的值">¶</a>范德蒙行列式的值</h3><p><img src="https://www.tangyulong.site/img/Math/Vandermonde/1.svg" alt="img"></p><p>这里</p><p><img src="https://www.tangyulong.site/img/Math/Vandermonde/4.webp" alt="img"></p><p>表示所有同类因子(xi-yi)<br>(其中 j&lt;i)的乘积，即</p><p><img src="https://www.tangyulong.site/img/Math/Vandermonde/5.webp" alt="img"></p><p><img src="https://www.tangyulong.site/img/Math/Vandermonde/6.webp" alt="img"></p><h1>举例</h1><p>计算行列式</p><p><img src="https://www.tangyulong.site/img/Math/Vandermonde/7.webp" alt="img"></p><p>注意到该行列式是一个第二行为 1，2，3，4 的四阶范德蒙行列式，于是有</p><p><img src="https://www.tangyulong.site/img/Math/Vandermonde/8.webp" alt="img"></p><h1>证明</h1><p>用<a href="">数学归纳法</a>作证明。</p><p>当 n=2 时，</p><p><img src="https://www.tangyulong.site/img/Math/Vandermonde/9.webp" alt="img"></p><p>结论成立，假设该结论对 n-1 阶范德蒙行列式成立，即</p><p><img src="https://www.tangyulong.site/img/Math/Vandermonde/10.webp" alt="img"></p><p>考虑 n 阶范德蒙行列式的情形</p><p><img src="https://www.tangyulong.site/img/Math/Vandermonde/11.webp" alt="img"></p><p>从第 n 行开始，自上而下依次的由下一行减去它上一行的 x1 倍 ，有</p><p><img src="https://www.tangyulong.site/img/Math/Vandermonde/12.webp" alt="img"></p><p><img src="https://www.tangyulong.site/img/Math/Vandermonde/13.webp" alt="img"></p><blockquote><p>这里使用的行列式 性质 5 <code>把行列式A的某行（或列）中各元同乘一数后加到另一行（或列）中各对应元上，结果仍然是A。</code></p></blockquote><p>按第一列展开后提取<a href="">公因式</a>，得</p><p><img src="https://www.tangyulong.site/img/Math/Vandermonde/14.webp" alt="img"></p><p><img src="https://www.tangyulong.site/img/Math/Vandermonde/17.webp" alt="img"></p><blockquote><p>这里根据行列式的一个 n×n 矩阵的行列式等于其任意行（或列）的元素与对应的<a href="">代数余子式</a>乘积之和 .展开的具体可以看这里这句话的含义。</p></blockquote><p>于是有</p><p><img src="https://www.tangyulong.site/img/Math/Vandermonde/16.webp" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>树的习题笔记</title>
      <link href="post/d4b00bd1.html"/>
      <url>post/d4b00bd1.html</url>
      
        <content type="html"><![CDATA[<div class="tip faa-horizontal animated"><p>在二叉树中有两个结点 m 和 n，若 m 是 n 的祖先，则使用后序遍历可以找到从 m 到 n 的路径</p></div><p>首先需要理解的是，前中后序遍历都是通过递归的方式，将后来需要用到的结点保存在栈中，比如下面这颗树：<br><img src="https://www.tangyulong.site/wp-content/uploads/2021/05/20190315010421380.png" alt=""></p><p>如果是前序遍历，根左右，过程是：根节点 m 入栈并输出，访问 m 的左孩子 a，a 入栈并输出，访问 a 的左孩子 c，c 入栈并输出，c 没有左孩子，无元素入栈，c 没有右孩子，无元素入栈，c 出栈，此时栈顶元素为 a，a 就出栈并访问，然后将 a 的右子树入栈，访问 a 元素的右孩子 d，d 入栈并输出，d 没有左孩子，无元素入栈，d 没有右孩子，无元素入栈，d 出栈，a 左右子树都访问完了所以出栈，<span class='p blue'>现在栈顶元素是m，m已经没有作用了所以出栈，</span>访问 m 的右孩子 b，m 的右孩子 b 入栈并输出，接着访问 b 的左孩子 e，e 入栈并输出……</p><p>如果中序遍历，左根右，过程是：根节点 m 入栈，访问 m 的左孩子，所以 m 的左孩子 a 入栈，访问 a 的左孩子，所以 a 的左孩子 c 入栈，c 没有左孩子，c 现在输出并出栈，c 没有右孩子所以没有元素入栈，现在栈顶元素是 a，a 输出并出栈，a 的右孩子 d 入栈，此时 d 没有左孩子所以没有元素入栈，d 输出并出栈，d 没有右孩子所以没有元素入栈，<span class='p blue'>现在栈顶元素是m，m输出，此时m已经没有作用了所以出栈，</span>m 的右孩子 b 入栈，访问 b 的左孩子，所以 b 的左孩子 e 入栈……</p><p>所以在前序和中序的过程中，如果 n 在 m 的右子树部分，遍历过程中找到了 n，但是 m 已经不在栈中，因为栈中只会保留等会需要用到的 e 和 b 结点，而 m 已经完成了访问根结点和 m 的左子树的任务，已经被出栈，<span class='p blue'>所以无法追溯n如何走到m。</span></p><p>但是后序遍历就不一样啦，后序的顺序是左右根，所以只要 m 的左右子树还没遍历完成，m 就不能出栈，在遍历 m 的左右子树过程中，无论在 m 的左边还是右边找到了 n，<span class='p blue'>都可以直接返回然后根据栈中的路径让n找到回到m的路，</span>这样就能找到 m 到 n 的路径～</p><p>所以一旦 n 在 m 的右子树，且离的较远，m 就会在前序和中序的过程中因为已经完成了访问左、访问根的任务，而被栈遗忘，让找到了 n 的时候也不知怎么回到 m……而只有后序会让作为祖先（子树的根）的 m 永远被铭记直到 n 找到 m 为止…</p><div class="tip faa-horizontal animated"><p>对这题有疑惑的应该是没理解题目的“路径”，不少人误认为“路径”是 visit()输出的序列顺序，而“路径”是遍历过程中栈中元素的顺序。后序遍历中 m 是第一个入栈最后一个出栈，当 n 入栈时在栈中就会有 m→n 的路径</p></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>三角函数</title>
      <link href="post/5640f8b3.html"/>
      <url>post/5640f8b3.html</url>
      
        <content type="html"><![CDATA[<ol><li><strong>诱导公式</strong></li><li><strong>二角和差公式</strong></li><li><strong>倍角公式</strong></li><li><strong>半角公式</strong></li><li><strong>和差化积&amp;积化和差公式</strong></li><li><strong>万能公式</strong></li><li><strong>三倍角公式</strong></li><li><strong>辅助角公式</strong></li><li><strong>反三角函数</strong></li></ol><h4 id="诱导公式"><a class="header-anchor" href="#诱导公式">¶</a>诱导公式</h4><p><strong>诱导公式理解</strong></p><p>※<em>奇变偶不变</em>：其中奇偶是指 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>π</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac {\pi} {2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>的奇偶数倍(倍数为 K)，变与不变看 k 是奇还是偶。变的话就是正余弦函数名互变、正余切函数名互变。</p><p>※<em>符号看象限</em>：首先我们把角当作一个<strong>锐角</strong>处理，当这个锐角加或减上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>k</mi><mi>π</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac {k \pi} {2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">kπ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 后(若加则把角的终边逆时针旋转，若减则把角的终边顺时针旋转)，然后看这个角是第几象限，其中函数符号要根据原函数(<strong>不是变化后的函数</strong>)来判断，最后由上表就可以判断出符号的正负了。</p><h4 id="二角和差公式"><a class="header-anchor" href="#二角和差公式">¶</a>二角和差公式</h4><p><img src="https://www.tangyulong.site/wp-content/uploads/2021/05/1.png" alt="公式"></p><h4 id="倍角公式"><a class="header-anchor" href="#倍角公式">¶</a>倍角公式</h4><p><img src="https://www.tangyulong.site/wp-content/uploads/2021/05/2.png" alt="公式"></p><h4 id="半角公式"><a class="header-anchor" href="#半角公式">¶</a>半角公式</h4><p><img src="https://www.tangyulong.site/wp-content/uploads/2021/05/3.png" alt="公式"></p><p><img src="https://www.tangyulong.site/wp-content/uploads/2021/05/4.png" alt="公式"></p><h4 id="和差化积-积化和差公式"><a class="header-anchor" href="#和差化积-积化和差公式">¶</a>和差化积&amp;积化和差公式</h4><h5 id="和差化积公式"><a class="header-anchor" href="#和差化积公式">¶</a>和差化积公式</h5><h6 id="公式及其特点"><a class="header-anchor" href="#公式及其特点">¶</a>公式及其特点</h6><p><img src="https://www.tangyulong.site/wp-content/uploads/2021/05/5.png" alt="公式"></p><p>公式特点：前四个等式左边是和的形式，右边为乘积的形式，且倍数为 2，第一个函数名后是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>α</mi><mo>+</mo><mi>β</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{\alpha+\beta}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.05278em;">β</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>.</p><h6 id="公式记忆法则-前四个"><a class="header-anchor" href="#公式记忆法则-前四个">¶</a>公式记忆法则(前四个)</h6><p>四个公式分别对应了一个口诀(通用版本)</p><p>⑴ 正加正，正在前。</p><p><img src="https://www.tangyulong.site/wp-content/uploads/2021/05/v2-e78b8d8f3a43e4a418aaf7a0b52430ef_720w.jpg" alt="img">图 15 公式 3-①</p><p>⑵ 余加余，余并肩。</p><p><img src="https://www.tangyulong.site/wp-content/uploads/2021/05/v2-f053031a59ab169542e0ff567e712306_720w.jpg" alt="img">图 16 公式 3-②</p><p>⑶ 正减正，余在前。</p><p><img src="https://www.tangyulong.site/wp-content/uploads/2021/05/v2-acc3c88adaf0cc37bd9f5f270cff675b_720w.jpg" alt="img">图 17 公式 3-③</p><p>⑷ 余减余，负正弦。<strong>(注意有负号!)</strong></p><p><img src="https://www.tangyulong.site/wp-content/uploads/2021/05/v2-6f9d91afd169106b22b5fba6f66a74fc_720w.jpg" alt="img">图 18 公式 3-④</p><h6 id="公式推理"><a class="header-anchor" href="#公式推理">¶</a>公式推理</h6><p>下面只给出公式 3-①、3-② 推导.</p><p>⑴ 公式 3-① 推导</p><p><strong>根据前面的公式 1-①、1-②。</strong></p><p><strong>sin(α+β)=sinα·cosβ+cosα·sinβ······1-①</strong></p><p><strong>sin(α-β)=sinα·cosβ-cosα·sinβ······1-②</strong></p><p><strong>二式相加，得</strong></p><p><strong>sin(α+β)+sin(α-β)=2sinα·cosβ, 记 α+β=θ；α-β=φ。解得 α=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>θ</mi><mo>+</mo><mi>φ</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{\theta+\varphi}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">φ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>;β=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>θ</mi><mo>−</mo><mi>φ</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{\theta-\varphi}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">φ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></strong></p><p><strong>代入式中即得 sinθ+sinφ=2sin</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>θ</mi><mo>+</mo><mi>φ</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{\theta+\varphi}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">φ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><strong>·cos</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>θ</mi><mo>−</mo><mi>φ</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{\theta-\varphi}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">φ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。</p><p><strong>⑵ 公式 3-② 推导</strong></p><p><img src="https://www.tangyulong.site/wp-content/uploads/2021/05/6.png" alt="公式"></p><h5 id="积化和差公式"><a class="header-anchor" href="#积化和差公式">¶</a>积化和差公式</h5><h6 id="公式及其特点-v2"><a class="header-anchor" href="#公式及其特点-v2">¶</a>公式及其特点</h6><p><strong>3-⑨: sinα·cosβ=</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><strong>[sin(α+β)+sin(α-β)]</strong></p><p><strong>3-⑩: cosα·cosβ=</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><strong>[cos(α+β)+cos(α-β)]</strong></p><p><strong>3-⑪: cosα·sinβ=</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><strong>[sin(α+β)-sin(α-β)]</strong></p><p><strong>3-⑫: sinα·sinβ=</strong> -<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><strong>[cos(α+β)-cos(α-β)]</strong></p><p>公式特点：等式左边是乘积的形式,等式的右边为和的形式且倍数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，第一个函数名里面是<strong>α+β</strong>；第二个函数名里面是<strong>α-β</strong>。</p><h6 id="公式记忆法则"><a class="header-anchor" href="#公式记忆法则">¶</a>公式记忆法则</h6><p>⑴ 积化和差得和差</p><p><img src="https://www.tangyulong.site/wp-content/uploads/2021/05/v2-f6f086a855daa909fa6d5742ddb66d93_720w.jpg" alt="img">图 19</p><p>⑵ 余弦在后要相加(正弦在后就相减)</p><p><img src="https://www.tangyulong.site/wp-content/uploads/2021/05/v2-bedcf94ffa82baf36c4e7600dbac1e50_720w.jpg" alt="img">图 20</p><p>⑶ 异名函数取正弦(同名函数取余弦)</p><p><img src="https://www.tangyulong.site/wp-content/uploads/2021/05/a.jpg" alt="img">图 21</p><p>⑷ 正弦相乘取负号(注意有负号!)</p><p><img src="https://www.tangyulong.site/wp-content/uploads/2021/05/v2-62f24e2043df0234c7fe7a451a076273_720w.jpg" alt="img">图 22</p><h6 id="公式推理-v2"><a class="header-anchor" href="#公式推理-v2">¶</a>公式推理</h6><p><strong>根据公式 1-①、1-②。</strong></p><p><strong>sin(α+β)=sinα·cosβ+cosα·sinβ······1-①</strong></p><p><strong>sin(α-β)=sinα·cosβ-cosα·sinβ······1-②</strong></p><p><strong>二式相加，得</strong></p><p><strong>sin(α+β)+sin(α-β)=2sinα·cosβ，等式两边同时除以 2 即可。</strong></p><h4 id="万能公式"><a class="header-anchor" href="#万能公式">¶</a>万能公式</h4><h5 id="1-公式内容"><a class="header-anchor" href="#1-公式内容">¶</a>1.公式内容</h5><p><img src="https://www.tangyulong.site/wp-content/uploads/2021/05/7.png" alt="公式"></p><h5 id="2-公式推理"><a class="header-anchor" href="#2-公式推理">¶</a><strong>2.公式推理</strong></h5><p>⑴ 公式 4-① 推导</p><p><img src="https://www.tangyulong.site/wp-content/uploads/2021/05/8.png" alt="[公式]"></p><p>⑵ 公式 4-② 推导</p><p><img src="https://www.tangyulong.site/wp-content/uploads/2021/05/9.png" alt="[公式]"></p><p>⑶ 公式 4-③(推导)</p><p><img src="https://www.tangyulong.site/wp-content/uploads/2021/05/10.png" alt="[公式]"></p><h4 id="三倍角公式"><a class="header-anchor" href="#三倍角公式">¶</a>三倍角公式</h4><h5 id="1-公式内容-记忆法则"><a class="header-anchor" href="#1-公式内容-记忆法则">¶</a><strong>1.公式内容&amp;记忆法则</strong></h5><p><strong>5-①:sin3α=-4sin³α+3sinα[负 4(倍)三方加 3(倍)角]</strong></p><p><strong>5-②:cos3α=4cos³α-3cosα[正 4(倍)三方减 3(倍)角]</strong></p><h5 id="2-公式推理-v2"><a class="header-anchor" href="#2-公式推理-v2">¶</a><strong>2.公式推理</strong></h5><p>⑴ 公式 5-① 推导</p><p><strong>sin3α=sin(α+2α)=sinα·cos2α+cosα·sin2α(公式 1-①)</strong></p><p><strong>=sinα·(1-2sin²α)+2cos²α·sinα(二倍角公式)</strong></p><p><strong>=sinα-2sin³α+2(1-sin²α)·sinα(&quot;1&quot;的妙用:sin²α+cos²α=1)</strong></p><p><strong>=-4sin³α+3sinα</strong></p><p>⑵ 公式 5-② 推导</p><p><strong>cos3α=cos(α+2α)=cosα·cos2α-sinα·sin2α(公式 1-③)</strong></p><p><strong>=cosα·(2cos²α-1)-2sin²α·cosα(二倍角公式)</strong></p><p><strong>=2cos³α-cosα-2(1-cos²α)·cosα(&quot;1&quot;的妙用:sin²α+cos²α=1)</strong></p><p><strong>=4cos³α-3cosα</strong></p><h4 id="辅助角公式"><a class="header-anchor" href="#辅助角公式">¶</a>辅助角公式</h4><p><strong>a·sinα+b·cosα=</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mroot><mrow><msup><mi>a</mi><mn>2</mn></msup><mo>+</mo><msup><mi>b</mi><mn>2</mn></msup></mrow><mrow></mrow></mroot></mrow><annotation encoding="application/x-tex">\sqrt[]{a^2+b^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.12661100000000003em;"></span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.47206679999999995em;"><span style="top:-2.4720668em;"><span class="pstrut" style="height:2em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.913389em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.873389em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12661100000000003em;"><span></span></span></span></span></span></span></span></span> <strong>sin(α+φ),其中 tanφ=</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>a</mi><mi>b</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{a}{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><strong>(φ=arctan<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>a</mi><mi>b</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{a}{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></strong>)。</p><h4 id="反三角函数"><a class="header-anchor" href="#反三角函数">¶</a>反三角函数</h4><p><strong>几个常用公式</strong></p><p><strong>1.</strong> <img src="https://www.zhihu.com/equation?tex=arcsinx%2Barccosx%3D%5Cfrac%7B%5Cpi%7D%7B2%7D%28%5Cleft%7C+x+%5Cright%7C%5Cleq1%29" alt="[公式]"></p><p><strong>2.</strong> <img src="https://www.zhihu.com/equation?tex=arctanx%2Barccotx%3D%5Cfrac%7B%5Cpi%7D%7B2%7D" alt="[公式]"></p><p><strong>3.</strong> <img src="https://www.zhihu.com/equation?tex=arctanx%2Barctan%5Cfrac%7B1%7D%7Bx%7D%3D%5Cfrac%7B%5Cpi%7D%7B2%7D%28x%EF%BC%9E0%29" alt="[公式]"></p><p><strong>4.</strong> <img src="https://www.zhihu.com/equation?tex=arctan%28e%5Ex%29%2Barctan%28e%5E%7B-x%7D%29%3D%5Cfrac%7B%5Cpi%7D%7B2%7D" alt="[公式]"></p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="post/2da0528d.html"/>
      <url>post/2da0528d.html</url>
      
        <content type="html"><![CDATA[<h3 id="串的模式匹配"><a class="header-anchor" href="#串的模式匹配">¶</a>串的模式匹配</h3><p>比如主串 s=“goodgoogle”,子串 t=“google”。现在我们要找到子串 t 在主串 s 中的位置。</p><h4 id="第一种-就是暴力求解法"><a class="header-anchor" href="#第一种-就是暴力求解法">¶</a>第一种 就是暴力求解法</h4><p>这种方法也叫 <span class='p red small'>朴素的模式匹配:</span></p><p>简单来说就是：从主串 s 和子串 t 的第一个字符开始，将两字符串的字符一一比对，如果出现某个字符不匹配，主串回溯到第二个字符，子串回溯到第一个字符再进行一一比对。如果出现某个字符不匹配，主串回溯到第三个字符，子串回溯到第一个字符再进行一一比对…一直到子串字符全部匹配成功。</p><details yellow><summary> 查看具体代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(sstring s,sstring t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; t.length &amp;&amp; t.length) &#123;</span><br><span class="line"><span class="keyword">if</span> (s.data[i] == t.data[j]) &#123;</span><br><span class="line">i++, j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">i = i - j + <span class="number">2</span>;</span><br><span class="line">j = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt; t.length)</span><br><span class="line"><span class="keyword">return</span> i - t.length;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details><h4 id="第二种-KMP-算法"><a class="header-anchor" href="#第二种-KMP-算法">¶</a>第二种 KMP 算法</h4><p>事实上，<strong>每一个字符前的字符串都有最长相等前后缀</strong>，而且<strong>最长相等前后缀的长度是我们移位的关键</strong>，所以我们单独用一个 next 数组存储子串的最长相等前后缀的长度。<strong>而且 next 数组的数值只与子串本身有关。</strong></p><h5 id="next-数组手算方法："><a class="header-anchor" href="#next-数组手算方法：">¶</a>next 数组手算方法：</h5><p>当第 j 个字符匹配失败，由前 1~j-1 个字符组成的串记为 S，则 next[j]=s 的最长相等前后缀长度+1，特别的，next[1]=0。所以 next[i]=j,含义是：下标为 i 的字符前的字符串最长相等前后缀的长度为 j。</p><blockquote><ol><li>next[i]的值表示下标为 i 的字符前的字符串最长相等前后缀的长度。</li><li>表示该处字符不匹配时应该回溯到的字符的下标。</li></ol></blockquote><details yellow><summary> 查看具体代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(sstring t, <span class="keyword">int</span> next[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">i = <span class="number">1</span>, j = <span class="number">0</span>; <span class="comment">//舍去一个存储空间，让数组中第i个位置的元素等于该字符在字符串中的位置,方便理解</span></span><br><span class="line">next[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//第一个字符前无字符，赋值为 0</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; t.length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span> || t.data[i] == t.data[j])<span class="comment">//j==0是当字符不匹配是，用来对i指针进行移位的。</span></span><br><span class="line">        &#123;</span><br><span class="line">i++, j++; <span class="comment">//一般来说 next[0] next[1] 的值都为1</span></span><br><span class="line">next[i] = j;</span><br><span class="line"><span class="comment">// 对应字符匹配情况下，s与t指向同步后移</span></span><br><span class="line"><span class="comment">// next[i] = j;表示在第i前面的子串的最大匹配值。当data[i]与data[j]的字符不匹配时，j会回溯到上一个能匹配的位置，然后再比较。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">j = next[j];</span><br><span class="line"><span class="comment">//next[j]的值代表的是下标为k的字符前面的字符串最长相等前后缀的长度</span></span><br><span class="line"><span class="comment">//也表示该处字符不匹配时应该回溯到的字符的下标</span></span><br><span class="line"><span class="comment">//这个值给j后又进行while循环判断，此时t.data[j]即指最长相等前缀后一个字符</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="KMP-算法的改进"><a class="header-anchor" href="#KMP-算法的改进">¶</a>KMP 算法的改进</h3><p>为什么 KMP 还需要改进？<br>如下例子:<br>主串 s=“aaaaabaaaaac”,子串 t=“aaaaac”<br>这个例子中当‘b’与‘c’不匹配时应该‘b’与’c’前一位的‘a’比,这显然是不匹配的。'c’前的’a’回溯后的字符依然是‘a’。</p><span class='p cyan'>我们知道没有必要再将‘b’与‘a’比对了</span>，因为回溯后的字符和原字符是相同的，原字符不匹配，回溯后的字符自然不可能匹配。但是 KMP 算法中依然会将‘b’与回溯到的‘a’进行比对。这就是我们可以改进的地方了。我们改进后的 next 数组命名为：nextval 数组。KMP 算法的改进可以简述为： <span class='p red'>如果 a 位字符与它 next 值指向的 b 位字符相等，则该 a 位的 nextval 就指向 b 位的 nextval 值，如果不等，则该 a 位的 nextval 值就是它自己 a 位的 next 值。</span>如字符串"ababaaab"的 next 数组以及 nextval 数组分别为：<table><thead><tr><th style="text-align:center">下标</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th></tr></thead><tbody><tr><td style="text-align:center">子串</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">next</td><td style="text-align:center">-1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">nextval</td><td style="text-align:center">-1</td><td style="text-align:center">0</td><td style="text-align:center">-1</td><td style="text-align:center">0</td><td style="text-align:center">-1</td><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><details yellow><summary> 查看具体代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNextval</span><span class="params">(SqString t,<span class="keyword">int</span> nextval[])</span></span></span><br><span class="line"><span class="function"><span class="comment">//由模式串t求出nextval值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>,k=<span class="number">-1</span>;</span><br><span class="line">nextval[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">while</span> (j&lt;t.length)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (k==<span class="number">-1</span> || t.data[j]==t.data[k])</span><br><span class="line">&#123;</span><br><span class="line">j++;k++;</span><br><span class="line"><span class="keyword">if</span> (t.data[j]!=t.data[k])</span><br><span class="line">                        <span class="comment">//这里的t.data[k]是t.data[j]处字符不匹配而会回溯到的字符</span></span><br><span class="line">                        <span class="comment">//为什么？因为没有这处if判断的话，此处代码是next[j]=k;</span></span><br><span class="line">                        <span class="comment">//next[j]不就是t.data[j]不匹配时应该回溯到的字符位置嘛</span></span><br><span class="line"></span><br><span class="line">nextval[j]=k;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">nextval[j]=nextval[k];</span><br><span class="line"></span><br><span class="line">                <span class="comment">//此时nextval[j]的值就是就是t.data[j]不匹配时应该回溯到的字符的nextval值</span></span><br><span class="line">                <span class="comment">//即字符不匹配时回溯两层后对应的字符下标</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">            k=nextval[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMPIndex1</span><span class="params">(SqString s,SqString t)</span></span></span><br><span class="line"><span class="function"><span class="comment">//修正的KMP算法</span></span></span><br><span class="line"><span class="function"><span class="comment">//只是next换成了nextval</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> nextval[MaxSize],i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">GetNextval</span>(t,nextval);</span><br><span class="line"><span class="keyword">while</span> (i&lt;s.length &amp;&amp; j&lt;t.length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j==<span class="number">-1</span> || s.data[i]==t.data[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> j=nextval[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j&gt;=t.length)</span><br><span class="line"><span class="keyword">return</span>(i-t.length);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in"><span class="keyword">return</span></span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="完整代码实现"><a class="header-anchor" href="#完整代码实现">¶</a>完整代码实现</h3><div class="tip faa-flash animated-hover"><p>代码中并不是所以函数都用上了的，主要实现的是 KMP 算法。</p></div><details blue><summary> 查看具体代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> *data;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line">&#125;sstring;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(sstring s,sstring t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>, j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; t.length &amp;&amp; t.length) &#123;</span><br><span class="line"><span class="keyword">if</span> (s.data[i] == t.data[j]) &#123;</span><br><span class="line">i++, j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">i = i - j + <span class="number">2</span>;</span><br><span class="line">j = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt; t.length)</span><br><span class="line"><span class="keyword">return</span> i - t.length;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(sstring t, <span class="keyword">int</span> next[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; t.length)</span><br><span class="line"><span class="comment">//因为next数组中j最大为t.length-1,而每一步next数组赋值都是在j++之后</span></span><br><span class="line"><span class="comment">//所以最后一次经过while循环时j为t.length-2</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span> || t.data[i] == t.data[j])<span class="comment">//k为-1或比较的字符相等时，这个条件，相当于直接从模式串的第一个和第二个开始比较走。</span></span><br><span class="line">&#123;</span><br><span class="line">i++, j++; <span class="comment">//第二个字符不匹配，必定回到第0个位置，一般来说next[0]=0;next[1]=1;</span></span><br><span class="line">next[i] = j;</span><br><span class="line"><span class="comment">// 对应字符匹配情况下，s与t指向同步后移,用i来记录当前串的长度，用j来记录最大匹配值</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">j = next[j];</span><br><span class="line"><span class="comment">//next[j]的值代表的是下标为j的字符前面的字符串最长相等前后缀的长度</span></span><br><span class="line"><span class="comment">//也表示该处字符不匹配时应该回溯到的字符的下标</span></span><br><span class="line"><span class="comment">//这个值给j后又进行while循环判断，此时t.data[j]即指最长相等前缀后一个字符</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNextVal</span><span class="params">(sstring t, <span class="keyword">int</span> nextval[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i&lt;t.length )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span> || t.data[i] == t.data[j]) &#123;</span><br><span class="line">++i; ++j;</span><br><span class="line"><span class="keyword">if</span> (t.data[i] != t.data[j])</span><br><span class="line">nextval[i] = j;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">nextval[i] = nextval[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">j = nextval[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMPIndex</span><span class="params">(sstring s,sstring t,<span class="keyword">int</span> next[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> ( i&lt;=s.length &amp;&amp;j&lt;=t.length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span> || s.data[i] == t.data[j]) &#123;</span><br><span class="line">i++, j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt; t.length)</span><br><span class="line"><span class="keyword">return</span> i - t.length;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sstring s, t;</span><br><span class="line"><span class="keyword">char</span> ss[] = <span class="string">&quot;aaaabbbbbccccccccccccd&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> st[] = <span class="string">&quot;cd&quot;</span>;</span><br><span class="line">s.data = ss;</span><br><span class="line">t.data = st;</span><br><span class="line"><span class="keyword">int</span> next[<span class="number">3</span>];</span><br><span class="line">s.length = <span class="built_in">strlen</span>(ss);</span><br><span class="line">t.length = <span class="built_in">strlen</span>(st);</span><br><span class="line"><span class="built_in">GetNext</span>(t, next);</span><br><span class="line"><span class="keyword">int</span> m = <span class="built_in">KMPIndex</span>(s, t,next);</span><br><span class="line">cout &lt;&lt; m &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details><div class='poem'><div class='poem-title'>水调歌头</div><div class='poem-author'>苏轼</div><p>丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。<br>明月几时有？把酒问青天。<br>不知天上宫阙，今夕是何年？<br>我欲乘风归去，又恐琼楼玉宇，高处不胜寒。<br>起舞弄清影，何似在人间？</p><p>转朱阁，低绮户，照无眠。<br>不应有恨，何事长向别时圆？<br>人有悲欢离合，月有阴晴圆缺，此事古难全。<br>但愿人长久，千里共婵娟。</p></div>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列的两种实现方式</title>
      <link href="post/c2ed.html"/>
      <url>post/c2ed.html</url>
      
        <content type="html"><![CDATA[<h4 id="队列的链式实现-🐨"><a class="header-anchor" href="#队列的链式实现-🐨">¶</a>队列的链式实现 🐨</h4><ul><li>🌻 链队的初始化实现采用的是不带头结点的方法，前边链式实现顺序表和栈时用的带头结点的方法，这次用不带头结点的方法，一是多掌握，二是考试考到可以做快。☁️<ul><li>初始化队列时由于不带头指针，在第一个位置加了一个 if()判断，区别于后边结点的插法。🐑</li><li>由于头指针和尾指针都是指向相同类型的结构体，把两个指针定义到同一个结构体中，否则，还要在 main()函数中定义头指针和尾指针，然后传入函数中操作，形参也要多定义一个。</li><li>由于没定义头结点，只能定义指针，在形参中一定注意使用引用</li></ul></li></ul><ul><li>➕ 自我反省<ul><li>⚠️ 自己做的时候在定义出队函数时没注意，然后运行时发现连续出队两次就报错,调试半天才发现在形参中未定义引用类型。再复习一次关于结点与指针是否使用引用 ⚠️</li><li>因为不定义引用类型，如果传进去的是个结点，系统在内存中开辟一片区域，里面存有和传入节点一样的 data，一样的 next，因为形参结点带有传入结点的 next 指针域，对复制的结点操作一样能改变原结点后边的结点。如果是指针的话，传入的是指针指向的地址，指针操作了结点后，不改变原来 main()函数的指针指向的地址，如果没对结点进行增删，再次调用函数，不会对原队列有影响，否则，传入的指针的会找不到指向的位置。定义了引用类型，上边的错误就不会存在。</li><li>详情参考 <code> bool DeQueue() ,EleType GetTop(),void Print(),string IsEmpty()</code>这四个函数形参的定义。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EleType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">EleType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;*LinkNode;</span><br><span class="line"><span class="comment">//将头指针尾指针放入一个结构体中</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">LinkNode front, rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">( LinkQueue&amp; r, EleType x)</span> </span>&#123;</span><br><span class="line">LinkNode q = r.rear, s;</span><br><span class="line">s = <span class="keyword">new</span> Node;</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">s-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">q-&gt;next = s;</span><br><span class="line">q = q-&gt;next;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;r, EleType&amp; x)</span> </span>&#123;</span><br><span class="line">LinkNode q;</span><br><span class="line"><span class="keyword">if</span> (r.front == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">x = <span class="number">999999999</span>;<span class="comment">//如果x打印为999999999表示链队列为空。</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">x = r.front-&gt;data;</span><br><span class="line">q = r.front;</span><br><span class="line">r.front = r.front-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> q;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="function">LinkNode <span class="title">InitQueue</span><span class="params">(LinkNode&amp; L, LinkQueue&amp; r, EleType a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*L = new Node;*/</span></span><br><span class="line">L = <span class="literal">nullptr</span>;</span><br><span class="line">LinkNode s;</span><br><span class="line">r.front = L;</span><br><span class="line">r.rear = L;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">s = <span class="keyword">new</span> Node;</span><br><span class="line">s-&gt;data = a[i];</span><br><span class="line">s-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">r.rear = s;</span><br><span class="line">s-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">r.front = r.rear;</span><br><span class="line">L = r.rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">r.rear-&gt;next = s;</span><br><span class="line">r.rear = s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取队头元素</span></span><br><span class="line"><span class="function">EleType <span class="title">GetTop</span><span class="params">(LinkQueue r)</span> </span>&#123;</span><br><span class="line">EleType x;</span><br><span class="line"><span class="keyword">if</span> (r.front == <span class="literal">nullptr</span>) <span class="comment">//记得加条件判断当前栈是否为空，否则当队列为空时，出队会出错。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">x = r.front-&gt;data;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function">string <span class="title">IsEmpty</span><span class="params">( LinkQueue r)</span> </span>&#123;</span><br><span class="line">string text;</span><br><span class="line"><span class="keyword">if</span> (r.front == <span class="literal">nullptr</span>)</span><br><span class="line">text = <span class="string">&quot;队列为空&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">text = <span class="string">&quot;队列不为空&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">( LinkQueue r)</span> </span>&#123;</span><br><span class="line">LinkNode s=r.front;</span><br><span class="line"><span class="keyword">while</span> (s!=<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; s-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">s = s-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LinkNode L;</span><br><span class="line">LinkQueue r;</span><br><span class="line">EleType x;</span><br><span class="line"><span class="comment">/*EleType a[] = &#123; 1,2,3,999,888,555 &#125;;*/</span></span><br><span class="line">EleType a[] = &#123; <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">InitQueue</span>(L, r, a, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">Print</span>(r);</span><br><span class="line">cout &lt;&lt; <span class="built_in">IsEmpty</span>( r) &lt;&lt; endl;</span><br><span class="line"><span class="built_in">GetTop</span>(r);</span><br><span class="line"><span class="built_in">EnQueue</span>( r, <span class="number">55</span>);</span><br><span class="line"><span class="built_in">Print</span>(r);</span><br><span class="line"><span class="built_in">DeQueue</span>( r, x);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"><span class="built_in">DeQueue</span>(r, x);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"><span class="built_in">DeQueue</span>(r, x);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="顺序队列的实现-⛅️"><a class="header-anchor" href="#顺序队列的实现-⛅️">¶</a>顺序队列的实现 ⛅️</h4><ul><li><p>由于顺序队列采用一般的数组的话，当出队入队多进行几次，就会出现上溢。🐐</p></li><li><p>采用循环数组可以提高空间利用率。🤡</p></li><li><p>核心是操作数组下标时，要采用取余的方式。👑</p></li><li><p>头指针指向第一个元素的位置，尾指针指向最后一个元素的位置，有三种判断队列是否为空，满的方式。🎲</p><ul><li>牺牲一个存储单元来判断队列是否为满，队满 L.rear + 1) % MaxSize == L.front % MaxSize；队空 L.front % MaxSize == L.rear % MaxSize；</li><li>增加一个变量存储当前的队列长度，就不用牺牲存储单元，length=0，空；length=MaxSize 满。</li><li>增加一个 flag 变量，如果出队就改变 flag = -1，入队 flag = 0。在判断 front == rear 时，flag = -1 队空，flag = 0 队满。</li></ul></li><li><p>头指针尾指针的位置并不是固定放在某个位置，看具体的题，具体判断。💮</p></li></ul><ul><li>自我反省关于多次调用 Print()函数出现错误 😢<ul><li>⚠️ 由于在 Print() 定义了引用变量，导致多次打印数组错误，对链式的数据结构，采用定义引用形参打印时没影响，静态数据结构用引用就会影响！⚠️</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EleType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">EleType data[MaxSize];</span><br><span class="line"><span class="keyword">int</span> front;</span><br><span class="line"><span class="keyword">int</span> rear;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line">&#125;SeqQueue;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SeqQueue&amp; L)</span> </span>&#123;</span><br><span class="line"><span class="comment">//顺序循环队列初始化将头指针和尾指针同时指向数组高端</span></span><br><span class="line"><span class="comment">//头指针指向第一个元素前的位置，尾指针指向最后一个元素的位置</span></span><br><span class="line">L.front = <span class="number">0</span>; <span class="comment">// front 指向队头元素</span></span><br><span class="line">L.rear = <span class="number">0</span>;  <span class="comment">// rear 指向队尾元素</span></span><br><span class="line">L.length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">while</span> (x != <span class="number">999</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (L.length &lt;= MaxSize)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">L.data[L.rear % MaxSize] = x;</span><br><span class="line">L.rear = (L.rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">&#125;</span><br><span class="line">L.length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(SeqQueue&amp; L)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L.rear == L.front - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryQueue</span><span class="params">(SeqQueue&amp; L)</span> </span>&#123;</span><br><span class="line">L.front = L.rear = MaxSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SeqQueue&amp; L, <span class="keyword">int</span>  x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((L.rear + <span class="number">1</span>) % MaxSize == L.front % MaxSize)<span class="comment">//牺牲一个存储单元来判断队列是否为满，队满，L.rear+1 = L.front；</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//if (L.length == MaxSize)//增加一个变量存储当前的队列长度，就不用牺牲存储单元</span></span><br><span class="line"><span class="comment">//return false;</span></span><br><span class="line"><span class="comment">//if (L.front % MaxSize == L.rear%MaxSize &amp;&amp; L.falg == -1)//增加一个变量存储最后一次的操作是出队还是入队，就不用牺牲存储单元</span></span><br><span class="line"><span class="comment">//return false;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">L.data[L.rear] = x;</span><br><span class="line">L.rear = (L.rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">L.length++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SeqQueue&amp; L, <span class="keyword">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L.front % MaxSize == L.rear % MaxSize)<span class="comment">//牺牲一个存储单元来判断队列是否为满，队空，和初始化一样，L.frontt = L.rear;</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//if (L.length == 0)//增加一个变量存储当前的队列长度，就不用牺牲存储单元</span></span><br><span class="line"><span class="comment">//return false;</span></span><br><span class="line"><span class="comment">//if (L.front % MaxSize == L.rear%MaxSize &amp;&amp; L.falg == -1)//增加一个变量存储最后一次的操作是出队还是入队，就不用牺牲存储单元</span></span><br><span class="line"><span class="comment">//return false;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">x = L.data[L.front];</span><br><span class="line">L.front = (L.front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">&#125;</span><br><span class="line">L.length--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">EleType <span class="title">GetHead</span><span class="params">(SeqQueue&amp; L, EleType&amp; x)</span> </span>&#123;</span><br><span class="line">x = L.data[L.front];</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(SeqQueue L)</span> </span>&#123;</span><br><span class="line">EleType num;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">num = (L.front) % MaxSize;</span><br><span class="line">cout &lt;&lt; L.data[num] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">L.front = (L.front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SeqQueue L = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">InitQueue</span>(L);</span><br><span class="line"><span class="built_in">Print</span>(L);</span><br><span class="line"><span class="built_in">EnQueue</span>(L, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">Print</span>(L);</span><br><span class="line"><span class="built_in">DeQueue</span>(L, x);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;出队元素：&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="post/e85d694a.html"/>
      <url>post/e85d694a.html</url>
      
        <content type="html"><![CDATA[<h4 id="二叉树的递归实现"><a class="header-anchor" href="#二叉树的递归实现">¶</a>二叉树的递归实现</h4><details blue><summary> 查看具体代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Element char</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Bitree</span> &#123;</span></span><br><span class="line">Element val;</span><br><span class="line">Bitree* lchild, * rchild;</span><br><span class="line"></span><br><span class="line">&#125;BiNode, * BiTree;</span><br><span class="line"><span class="comment">//递归生成树</span></span><br><span class="line"><span class="function">BiNode *<span class="title">CreatBiTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">BiTree bt;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">cin&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">&#x27;#&#x27;</span>) bt=<span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">bt = <span class="keyword">new</span> <span class="built_in">BiNode</span>();</span><br><span class="line">bt-&gt;val = ch;</span><br><span class="line">bt-&gt;lchild = <span class="built_in">CreatBiTree</span>();</span><br><span class="line">bt-&gt;rchild = <span class="built_in">CreatBiTree</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree bt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bt == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; bt-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">PreOrder</span>(bt-&gt;lchild);</span><br><span class="line"><span class="built_in">PreOrder</span>(bt-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree bt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bt == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">InOrder</span>(bt-&gt;lchild);</span><br><span class="line">cout &lt;&lt; bt-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">InOrder</span>(bt-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归的后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree bt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bt == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">PostOrder</span>(bt-&gt;lchild);</span><br><span class="line"><span class="built_in">PostOrder</span>(bt-&gt;rchild);</span><br><span class="line">cout &lt;&lt; bt-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree bt)</span> </span>&#123;</span><br><span class="line">queue&lt;BiTree&gt; q;</span><br><span class="line">BiTree p = bt;</span><br><span class="line">q.<span class="built_in">push</span>(p);</span><br><span class="line"><span class="keyword">if</span> (bt == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">p = q.<span class="built_in">front</span>(); <span class="comment">//p指针指向队头元素的引用</span></span><br><span class="line">q.<span class="built_in">pop</span>(); <span class="comment">//出队一个指针元素</span></span><br><span class="line">cout &lt;&lt; p-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//打印结点值</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;lchild != <span class="literal">nullptr</span>) <span class="comment">//判断入队结点是否为空</span></span><br><span class="line">q.<span class="built_in">push</span>(p-&gt;lchild);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;rchild != <span class="literal">nullptr</span>) <span class="comment">//判断入队结点是否为空</span></span><br><span class="line">q.<span class="built_in">push</span>(p-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清空树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearNode</span><span class="params">(BiTree bt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bt == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ClearNode</span>(bt-&gt;lchild);</span><br><span class="line"><span class="built_in">ClearNode</span>(bt-&gt;rchild);</span><br><span class="line"><span class="keyword">delete</span> bt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTree bt = <span class="built_in">CreatBiTree</span>();</span><br><span class="line"><span class="built_in">PreOrder</span>(bt);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="built_in">InOrder</span>(bt);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="built_in">PostOrder</span>(bt);</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">LevelOrder</span>(bt)</span><br><span class="line"><span class="built_in">ClearNode</span>(bt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试数据 AB#D##C##</span></span><br></pre></td></tr></table></figure>              </div>            </details><h4 id="二叉树的非递归实现"><a class="header-anchor" href="#二叉树的非递归实现">¶</a>二叉树的非递归实现</h4><details blue><summary> 查看具体代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Element char</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Bitree</span> &#123;</span></span><br><span class="line">Element val;</span><br><span class="line">Bitree* lchild, * rchild;</span><br><span class="line"></span><br><span class="line">&#125;BiNode, * BiTree;</span><br><span class="line"><span class="comment">//递归生成树</span></span><br><span class="line"><span class="function">BiNode* <span class="title">CreatBiTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">BiTree bt;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">cin &gt;&gt; ch;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>) bt = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">bt = <span class="keyword">new</span> <span class="built_in">BiNode</span>();</span><br><span class="line">bt-&gt;val = ch;</span><br><span class="line">bt-&gt;lchild = <span class="built_in">CreatBiTree</span>();</span><br><span class="line">bt-&gt;rchild = <span class="built_in">CreatBiTree</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree bt)</span> </span>&#123;</span><br><span class="line">stack&lt;BiTree&gt; s;</span><br><span class="line">BiTree p = bt, q = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (bt == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>() || p) &#123; <span class="comment">//栈不为空或者指向当前结点的指针不为空</span></span><br><span class="line"><span class="keyword">if</span> (p) &#123;</span><br><span class="line">s.<span class="built_in">push</span>(p); <span class="comment">//压入栈中</span></span><br><span class="line">cout &lt;&lt; p-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//访问根节点</span></span><br><span class="line">p = p-&gt;lchild; <span class="comment">//指针向左移动</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">q = s.<span class="built_in">top</span>();</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">p = q-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree bt)</span> </span>&#123;</span><br><span class="line">stack&lt;BiTree&gt; s;</span><br><span class="line">BiTree p = bt, q = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (bt == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>() || p) &#123; <span class="comment">//栈不为空或者指向当前结点的指针不为空</span></span><br><span class="line"><span class="keyword">if</span> (p) &#123;    <span class="comment">//一路向左</span></span><br><span class="line">s.<span class="built_in">push</span>(p); <span class="comment">//压入栈中</span></span><br><span class="line">p = p-&gt;lchild; <span class="comment">//左孩子不为空，指针向左移动</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">q = s.<span class="built_in">top</span>();     <span class="comment">//出栈，并转向出栈结点的右子树</span></span><br><span class="line">cout &lt;&lt; q-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//访问出栈节点</span></span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">p = q-&gt;rchild; <span class="comment">//向右子树走，p赋值为当前结点的右孩子</span></span><br><span class="line">   <span class="comment">//返回while循环，进入if-else 语句</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归的后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree bt)</span> </span>&#123;</span><br><span class="line">stack&lt;BiTree&gt; s;</span><br><span class="line">BiTree p = bt,q , r = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (bt == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>() || p) &#123; <span class="comment">//栈不为空或者指向当前结点的指针不为空</span></span><br><span class="line"><span class="keyword">if</span> (p) &#123;    <span class="comment">//一路向左</span></span><br><span class="line">s.<span class="built_in">push</span>(p); <span class="comment">//压入栈中</span></span><br><span class="line">p = p-&gt;lchild; <span class="comment">//左孩子不为空，指针向左移动</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">q = s.<span class="built_in">top</span>();     <span class="comment">//访问栈顶元素但是不出栈</span></span><br><span class="line"><span class="keyword">if</span> (q-&gt;rchild &amp;&amp; q-&gt;rchild != r) <span class="comment">//右子树存在且未被访问过</span></span><br><span class="line">p = q-&gt;rchild; <span class="comment">//转向右</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">cout &lt;&lt; q-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">r = q; <span class="comment">//记录最近访问过的结点</span></span><br><span class="line">q = <span class="literal">nullptr</span>; <span class="comment">//访问结点完成后，重置q指针</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree bt)</span> </span>&#123;</span><br><span class="line">queue&lt;BiTree&gt; q;</span><br><span class="line">BiTree p = bt;</span><br><span class="line">q.<span class="built_in">push</span>(p);</span><br><span class="line"><span class="keyword">if</span> (bt == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">p = q.<span class="built_in">front</span>(); <span class="comment">//p指针指向队头元素的引用</span></span><br><span class="line">q.<span class="built_in">pop</span>(); <span class="comment">//出队一个指针元素</span></span><br><span class="line">cout &lt;&lt; p-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//打印结点值</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;lchild != <span class="literal">nullptr</span>) <span class="comment">//判断入队结点是否为空</span></span><br><span class="line">q.<span class="built_in">push</span>(p-&gt;lchild);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;rchild != <span class="literal">nullptr</span>) <span class="comment">//判断入队结点是否为空</span></span><br><span class="line">q.<span class="built_in">push</span>(p-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清空树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearNode</span><span class="params">(BiTree bt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bt == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ClearNode</span>(bt-&gt;lchild);</span><br><span class="line"><span class="built_in">ClearNode</span>(bt-&gt;rchild);</span><br><span class="line"><span class="keyword">delete</span> bt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTree bt = <span class="built_in">CreatBiTree</span>();</span><br><span class="line"><span class="built_in">PreOrder</span>(bt);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="built_in">InOrder</span>(bt);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="built_in">PostOrder</span>(bt);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="built_in">LevelOrder</span>(bt);</span><br><span class="line"><span class="built_in">ClearNode</span>(bt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试数据 AB#D##C##</span></span><br></pre></td></tr></table></figure>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间再现</title>
      <link href="post/8df68e5d.html"/>
      <url>post/8df68e5d.html</url>
      
        <content type="html"><![CDATA[<h4 id="区间再现公式的使用场景"><a class="header-anchor" href="#区间再现公式的使用场景">¶</a>区间再现公式的使用场景</h4><p><img src="https://www.tangyulong.site/wp-content/uploads/2021/05/qujianzaixian.png" alt="公式"></p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求极限</title>
      <link href="post/bcb3582b.html"/>
      <url>post/bcb3582b.html</url>
      
        <content type="html"><![CDATA[<h4 id="极限的定义"><a class="header-anchor" href="#极限的定义">¶</a>极限的定义</h4><ol><li><p>如果商的极限等于分子和分母求极限后取商 需要分子和分母极限同时存在 否则极限的四则运算不成立 分母极限是无穷 所以不成立。附图🔗</p><img src='../../images/math/ultra.jpg' width="700px" style="margin:0 auto;"></li></ol>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序表的动态扩容</title>
      <link href="post/5e54.html"/>
      <url>post/5e54.html</url>
      
        <content type="html"><![CDATA[<h4 id="顺序表的动态扩容"><a class="header-anchor" href="#顺序表的动态扩容">¶</a>顺序表的动态扩容</h4><ul><li><p>插入操作判断位置是否合法(位置取值范围在 1~length+1），另外还要判断当前表是否为满(L.length &gt;= L.MaxSize)。 💃</p><ul><li><p>把每个元素往后移动一位，直到输入的插入的位置 ​ 💪💪💪。</p></li><li><p>第 n 个位置对应的值在数组中的值为 data[n-1]。</p></li><li><p>代码操作如下：</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertList</span><span class="params">(SeqList L, <span class="keyword">int</span> i, <span class="keyword">int</span> e)</span> <span class="comment">//插入操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (L.length &gt;= L.MaxSize)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = L.length; j &gt;= i; j--)</span><br><span class="line">  &#123;</span><br><span class="line">    L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  L.data[i - <span class="number">1</span>] = e;</span><br><span class="line">  L.length++;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除操作判断位置是否合法（位置取值范围 1~length），另外还要判断当前表是否为空 L.length &lt;= 0。🐓 ​</p><ul><li><p>取出删除位置的元素，然后把每个元素往前移动一位，直到输入的删除的位置。🐶</p></li><li><p>第 n 个位置对应的值在数组中的值为 data[n-1]。</p></li><li><p>代码操作如下：</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteList</span><span class="params">(SeqList L, <span class="keyword">int</span> i, <span class="keyword">int</span> &amp;e)</span> <span class="comment">//删除操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (L.length &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  e = L.data[i - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; L.length; j--)</span><br><span class="line">  &#123;</span><br><span class="line">    L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  L.length--;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>🍰 ⏯</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> *data;</span><br><span class="line"><span class="keyword">int</span> MaxSize;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line">&#125; SeqList;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SeqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">L.data = <span class="keyword">new</span> <span class="keyword">int</span>[InitSize];</span><br><span class="line">L.MaxSize = InitSize;</span><br><span class="line">L.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IncreaseList</span><span class="params">(SeqList L, <span class="keyword">int</span> len)</span> <span class="comment">//动态扩容</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = L.data;</span><br><span class="line">L.data = <span class="keyword">new</span> <span class="keyword">int</span>[(L.MaxSize + len)];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">  L.data[i] = p[i];</span><br><span class="line">&#125;</span><br><span class="line">L.MaxSize = L.MaxSize + len;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertList</span><span class="params">(SeqList L, <span class="keyword">int</span> i, <span class="keyword">int</span> e)</span> <span class="comment">//插入操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (L.length &gt;= L.MaxSize)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = L.length; j &gt;= i; j--)</span><br><span class="line">&#123;</span><br><span class="line">  L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">L.data[i - <span class="number">1</span>] = e;</span><br><span class="line">L.length++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//length=位置</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteList</span><span class="params">(SeqList L, <span class="keyword">int</span> i, <span class="keyword">int</span> &amp;e)</span> <span class="comment">//删除操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (L.length &lt;= <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">e = L.data[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; L.length; j--)</span><br><span class="line">&#123;</span><br><span class="line">  L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">L.length--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLocate</span><span class="params">(SeqList L, <span class="keyword">int</span> e)</span> <span class="comment">//按值查找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">  <span class="keyword">if</span> (L.data[i] == e)</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElement</span><span class="params">(SeqList L, <span class="keyword">int</span> i)</span> <span class="comment">//按位查找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Put</span><span class="params">(SeqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, L.data[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SeqList L;</span><br><span class="line"><span class="built_in">InitList</span>(L);</span><br><span class="line"><span class="built_in">InsertList</span>(L, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">InsertList</span>(L, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">InsertList</span>(L, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">Put</span>(L);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈的两种实现方式</title>
      <link href="post/e2a9.html"/>
      <url>post/e2a9.html</url>
      
        <content type="html"><![CDATA[<h4 id="🙌-顺序栈-🙌"><a class="header-anchor" href="#🙌-顺序栈-🙌">¶</a>🙌 顺序栈 🙌</h4><ul><li>Push()函数判满 -&gt; 顺序栈用的是数组，下标从 0 开始，top = MaxSize-1 ; 栈满 ; 🚀</li><li>Pop()函数判空 -&gt; 顺序栈用的是数组，下标从 0 开始，top = -1;栈空; 🚀</li><li>Print()函数遍历打印完全 -&gt; top 相当于数组的下标，i&lt;S.top 才能把栈遍历完全。🚀</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EleType;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">EleType data[MaxSize];</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line">&#125;SeqStack;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SeqStack&amp; S)</span> </span>&#123;</span><br><span class="line">S.top = <span class="number">-1</span>;</span><br><span class="line">S.length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">while</span> (x != <span class="number">999</span>&amp;&amp; S.length &lt; MaxSize) &#123; <span class="comment">//用length&lt;MaxSize 确保构造的栈不会溢出</span></span><br><span class="line">S.data[++S.top] = x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">S.length++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SeqStack&amp; S, EleType x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == MaxSize - <span class="number">1</span>)<span class="comment">//顺序栈用的是数组，下标从0开始，top = MaxSize-1;栈满;</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">S.data[++S.top] = x;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SeqStack&amp; S, EleType&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == <span class="number">-1</span>)<span class="comment">//顺序栈用的是数组，下标从0开始，top = -1;栈空;</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x = S.data[S.top--];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(SeqStack&amp; S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= S.top; i++)<span class="comment">//top相当于数组的下标，i&lt;S.top 才能把栈遍历完全。</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; S.data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">SeqStack S = &#123;&#125;;</span><br><span class="line"><span class="built_in">InitStack</span>(S);</span><br><span class="line"><span class="built_in">Push</span>(S, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">Print</span>(S);</span><br><span class="line"><span class="built_in">Pop</span>(S, x);</span><br><span class="line"><span class="built_in">Print</span>(S);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="🐘-栈的链式存储-🐘"><a class="header-anchor" href="#🐘-栈的链式存储-🐘">¶</a>🐘 栈的链式存储 🐘</h3><ul><li>下边代码用的是带头结点的写法，题中如果说明了要用未带头结点的写法，要注意。 😢</li><li>链栈初始化和链表初始化一样。😆</li><li>入栈出栈在头结点后操作。 👽</li></ul><h4 id="自我反省"><a class="header-anchor" href="#自我反省">¶</a>自我反省</h4><ul><li>出栈要判断栈是否为空，取栈顶元素也要判断栈顶是否为空(⚠️ 在第一次写时就没有在 GetTop()函数中判断 ⚠️ )</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EleType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">EleType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Stack, * LinkStack;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(LinkStack&amp; L, EleType x)</span> </span>&#123;</span><br><span class="line">LinkStack r = L-&gt;next, s;</span><br><span class="line">s = <span class="keyword">new</span> Node;</span><br><span class="line">s-&gt;next = r;</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">L-&gt;next = s;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(LinkStack&amp; L, EleType&amp; x)</span> </span>&#123;</span><br><span class="line">LinkStack r = L-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (r == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">x = <span class="number">999999999</span>; <span class="comment">//如果x打印为999999999表示链栈为空。</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">x = r-&gt;data;</span><br><span class="line">L-&gt;next = r-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> r;</span><br><span class="line">r = L-&gt;next;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Stack* <span class="title">InitStack</span><span class="params">(LinkStack&amp; L)</span> </span>&#123;</span><br><span class="line">L = <span class="keyword">new</span> Node;</span><br><span class="line">L-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">LinkStack s, r = L;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">while</span> (x != <span class="number">999</span>) &#123;</span><br><span class="line">s = <span class="keyword">new</span> Node;</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">s-&gt;next = r-&gt;next;</span><br><span class="line">r-&gt;next = s;</span><br><span class="line">r = r-&gt;next;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">EleType <span class="title">GetTop</span><span class="params">(LinkStack&amp; L)</span> </span>&#123;</span><br><span class="line">EleType x;</span><br><span class="line">LinkStack r = L-&gt;next;</span><br><span class="line">  <span class="keyword">if</span> (r == <span class="literal">nullptr</span>) <span class="comment">//记得加条件判断当前栈是否为空，否则当栈为空时，出栈会出错。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">x = r-&gt;data;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LinkStack L;</span><br><span class="line">EleType x;</span><br><span class="line"><span class="built_in">InitStack</span>(L);</span><br><span class="line"><span class="built_in">GetTop</span>(L);</span><br><span class="line"><span class="built_in">Push</span>(L, <span class="number">55</span>);</span><br><span class="line"><span class="built_in">Pop</span>(L, x);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形参指针变量和引用</title>
      <link href="post/7394.html"/>
      <url>post/7394.html</url>
      
        <content type="html"><![CDATA[<p>🤡 🤡 🤡</p><p><strong>一、使用 typedef 定义结构体</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个名字为TreeNode的结构体类型（现在并没有定义结构体变量，并不占用内存空间）：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> Element;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">LeftChild</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">RightChild</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 为结构体起一个别名Node，这时Node就等价于struct TreeNode</span></span><br><span class="line"><span class="comment">   typedef struct TreeNode Node;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> Element;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">LeftChild</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">RightChild</span>;</span></span><br><span class="line">&#125; *PtrToTreeNode;               <span class="comment">//直接定义指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将结构体的定义和typedef语句可以连在一起写</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> Element;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">LeftChild</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">RightChild</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//融合两种写法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>    <span class="comment">//类型定义</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure><p><strong>函数形参指针变量引用总结</strong> （参考下方的相关代码定义）</p><ul><li><p>定义 LinkList 时,LNode *L=LinkList L;</p></li><li><p>在 main()函数中定义时指针变量要初始化指针为空，c++中初始化指针为 nullptr 最好，不然会报错。</p></li><li><p>此时指针 L 初始化为空，L 的值为空。</p></li><li><p>在 main()函数中定义的 L 指针如果没有先指向一个结点，那么 MethodA 的形参 L 获得的值为空，那么在 MethodA 中对 L 进行操作后，结果不改变 main()函数中的 L；</p></li><li><p>反之，在调用 MethodA 方法之前在 main()函数中给指针 L 赋值（new 一个结点让 L 指向该结点），那么就算在形参中不定义引用类型（给传入的变量取别名,如 MethodB 的形参定义），也能改变 main()函数中的指针 L；因为 main()函数中 L 指针指向的是一个地址，地址赋值给形参中的 L 后那么函数中的 L 也是对地址操作，就能改变 main 函数中的 L 指针；</p><p>🚀 🚀 🚀</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>    <span class="comment">//类型定义</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"><span class="comment">// LinkList L = LNode *L;</span></span><br><span class="line"><span class="function">Status <span class="title">MethodA</span><span class="params">(LinkList L)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">MethodB</span><span class="params">(LinkList &amp;L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinKList L;</span><br><span class="line">    <span class="built_in">MethodA</span>(L);</span><br><span class="line">    <span class="built_in">MethodB</span>(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🚀 🚀 🚀</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++结构体与指针</title>
      <link href="post/9c11.html"/>
      <url>post/9c11.html</url>
      
        <content type="html"><![CDATA[<p><strong>结构体的使用：</strong><br>为什么使用结构体：<br>为了比表示一些复杂的数据结构，而满足用户需求的.<br>什么叫做结构体:<br>把一些基本的数据组合在一起形成一个新的复合数据类型，这个叫做结构体.<br><strong>1、如何定义一个结构体：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//（1）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//第一种定义结构的体即只定义了一个新的数据类型，并没有定义结构体变量（建议用此方法）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">float</span> score;</span><br><span class="line">   <span class="keyword">char</span> sex;</span><br><span class="line">&#125;;<span class="comment">//分好不能忘</span></span><br><span class="line"><span class="comment">//(2)第二种定义结构的方法定义结构体的同时定义结构体变量的命（不建议用此方法）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">float</span> score;</span><br><span class="line">   <span class="keyword">char</span> sex;</span><br><span class="line">&#125;stu2;</span><br><span class="line"><span class="comment">//第三种定义结构体的方式（这样也不好）这样没有结构体的名字</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">float</span> score;</span><br><span class="line">   <span class="keyword">char</span> sex;</span><br><span class="line">&#125;stu3;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span> =</span>&#123;<span class="number">80</span>,<span class="number">66.6</span>,<span class="string">&#x27;F&#x27;</span>&#125;;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、怎样使用结构体变量</strong><br><strong>赋值和初始化</strong><br>(1)初始化 定义的同时初始化附初始值<br>(2)定义完成后没有赋值只能一个一个的赋值<br><strong>如何取出结构体中的每一个成员</strong><br>(1) 结构体变量名.成员名<br>(2) 指针变量名-&gt;成员名(常用)<br>指针变量名-&gt;成员名 在计算机内部会被转化成 (*指针变量名).成员名 的方式来执行</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">float</span> score;</span><br><span class="line">   <span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span> =</span>&#123;<span class="number">80</span>,<span class="number">66.6f</span>,<span class="string">&#x27;F&#x27;</span>&#125;;<span class="comment">//初始化   定义的同时初始化附初始值</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st2</span>;</span><span class="comment">//定义完成后没有赋值只能一个一个的赋值</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> * <span class="title">pst</span> =</span> &amp;st;</span><br><span class="line">   st2.age = <span class="number">15</span>;</span><br><span class="line">   st2.score = <span class="number">3.1f</span>;<span class="comment">//C语言重66.6默认为double类型，如果希望是float类型则必须在末尾加f或者F</span></span><br><span class="line">   st2.sex = <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">   pst-&gt;age = <span class="number">99</span>;<span class="comment">//pst-&gt;age 在计算机内部会被转化成(*pst).age 也等价于st.age来执行</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;普通.运算符对结构体成员的操作结果: %d %f %c\n&quot;</span>,st2.age,st2.score,st2.sex);<span class="comment">//取值  结构体变量名.成员名</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;普通.运算符对结构体成员的操作结果: %d %f %c\n&quot;</span>,st.age,st.score,st.sex);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,pst-&gt;age);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>1、pst-&gt;age 在计算机内部会被转化成 (*pst).age<br>2、所以 pst-&gt;age 等价于 (*pst).age 也等价于 st.age<br>3、我们知道 pst-&gt;age 等价于 (*pst).age ,是因为 pst-&gt;age 是被转化成了(*pst).age 来执行的<br>4、pst-&gt;age 的含义： pst 所指向那个结构体变量中 age 这个成员<br><strong>结构体变量和结构体指针作为函数参数传递的问题</strong><br>推荐用结构体指针变量作为函数的参数来传递<br><strong>结构体重的变量的运算</strong><br>结构体变量不能相加，不能相减，也不能相互乘除，但可以相互赋值<br>结构体成员变量可以加减乘除运算</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">char</span> sex;</span><br><span class="line">   <span class="keyword">char</span> name;</span><br><span class="line">&#125;;<span class="comment">//分号不能少</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st1</span>,<span class="title">st2</span>;</span></span><br><span class="line">st1 + st2; st1*st2;st1/st2;  <span class="comment">//这些都是错的</span></span><br><span class="line">st1 = st2；<span class="comment">//这是对的</span></span><br></pre></td></tr></table></figure><p>1、要想通过函数对结构体成员变量进行操作（即修改结构体成员变量时）必须用结构体指针，形参为结构体变量的地址，否则访问不到结构体成员变量.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> age;<span class="comment">//4个字节</span></span><br><span class="line"><span class="keyword">char</span> sex;<span class="comment">//1个字节</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];<span class="comment">//100字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InpoutStudentInfo</span><span class="params">(struct Student stu)</span></span>;<span class="comment">//前置声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span>;</span></span><br><span class="line"><span class="comment">//pritnf(&quot;%d&quot;,sizeof(st));</span></span><br><span class="line"><span class="built_in">InpoutStudentInfo</span>(st);<span class="comment">//对结构体变量的输入</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %c %s\n&quot;</span>,st.age,st.sex,st.name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InpoutStudentInfo</span><span class="params">(struct Student stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   stu.age = <span class="number">10</span>;</span><br><span class="line">   <span class="built_in">strcpy</span>(stu.name,<span class="string">&quot;张三&quot;</span>);<span class="comment">//不能写成stu.name=&quot;张三&quot;;不行</span></span><br><span class="line">   stu.sex =<span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果为乱码：</strong></p><p>原因是当我们用函数操作时，其实是开辟了一段临时空间，当把结构体变量当做实参传进函数时，实际上是把结构体变量中的结构体成员在函数中复制了一份，函数运行时操作的只不过是函数临时开辟空间中存放的结构体成员变量，并没有操作到原来的结构体中的结构体成员变量。当函数运行结束后，开辟的临时空间将会销毁，在函数中对结构体成员变量的操作结果也被销毁，此时传进的结构体变量 st 并没有用到，那么他输出的是没有赋初值的结构体变量，里面是内存中的一些垃圾数据。</p><p>2、要想对结构体成员变量进行操作需实参要穿进结构体变量的首地址，形参为结构体变量的指针用于接收实参传进来的结构体变量的首地址，通过地址我们可以找到结构体成员变量然后进行修改。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> age;<span class="comment">//4个字节</span></span><br><span class="line"><span class="keyword">char</span> sex;<span class="comment">//1个字节</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];<span class="comment">//100字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InpoutStudentInfo</span><span class="params">(struct Student * pstu)</span></span>;<span class="comment">//前置声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span>;</span></span><br><span class="line"><span class="comment">//pritnf(&quot;%d&quot;,sizeof(st));</span></span><br><span class="line"><span class="built_in">InpoutStudentInfo</span>(&amp;st);<span class="comment">//对结构体变量的输入</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;分数: %d 性别: %c 姓名: %s\n&quot;</span>,st.age,st.sex,st.name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InpoutStudentInfo</span><span class="params">(struct Student * pstu)</span><span class="comment">//pstu占4个字节</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   pstu-&gt;age = <span class="number">10</span>;</span><br><span class="line">   <span class="built_in">strcpy</span>(pstu-&gt;name,<span class="string">&quot;张三&quot;</span>);<span class="comment">//不能写成stu.name=&quot;张三&quot;;不行</span></span><br><span class="line">   pstu-&gt;sex =<span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、当我们用函数仅用来输出结构体成员变量此时可以用结构体变量做实参，缺点是相当消耗空间，因为函数临时开辟的空间需要存的下传进来的结构体变量。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> age;<span class="comment">//4个字节</span></span><br><span class="line"><span class="keyword">char</span> sex;<span class="comment">//1个字节</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];<span class="comment">//100字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InpoutStudentInfo</span><span class="params">(struct Student * pstu)</span></span>;<span class="comment">//前置声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutpoutStudentInfo</span><span class="params">(struct Student stu)</span></span>;<span class="comment">//对结构体变量的输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span>;</span></span><br><span class="line"><span class="comment">//pritnf(&quot;%d&quot;,sizeof(st));</span></span><br><span class="line"><span class="built_in">InpoutStudentInfo</span>(&amp;st);<span class="comment">//对结构体变量的输入</span></span><br><span class="line"><span class="built_in">OutpoutStudentInfo</span>(st);<span class="comment">//对结构体变量的输出不建议用因为传进的参数太占空间了参数st总共占了105个字节</span></span><br><span class="line">    <span class="comment">//机器对齐填充数据组成原理中的知识导致108个字节</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InpoutStudentInfo</span><span class="params">(struct Student * pstu)</span><span class="comment">//pstu占4个字节</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   pstu-&gt;age = <span class="number">10</span>;</span><br><span class="line">   <span class="built_in">strcpy</span>(pstu-&gt;name,<span class="string">&quot;张三&quot;</span>);<span class="comment">//不能写成stu.name=&quot;张三&quot;;不行</span></span><br><span class="line">   pstu-&gt;sex =<span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutpoutStudentInfo</span><span class="params">(struct Student st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;函数临时开辟的空间大小为%d个字节\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(st));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;分数: %d 性别: %c 姓名: %s\n&quot;</span>,st.age,st.sex,st.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时发现输出结构体的函数需要开辟一个能存放结构体中所有的成员的内存空间，这样想到耗内存，而且运行慢。</p><p>4、为了减小内存开销，使运行更快我们输出结构体成员变量时实参为结构体的变量，形参为结构体变量的指针接收结构体变量的地址。优点是内存开销较小，运行快，缺点：不安全，因为在输出函数中可以对结构体的成员变量进行修改（但是我们可以用 const 来修饰形参避免对结构体的成员变量的修改）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> age;<span class="comment">//4个字节</span></span><br><span class="line"><span class="keyword">char</span> sex;<span class="comment">//1个字节</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];<span class="comment">//100字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InpoutStudentInfo</span><span class="params">(struct Student * pstu)</span></span>;<span class="comment">//前置声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutpoutStudentInfo</span><span class="params">(struct Student * stu)</span></span>;<span class="comment">//对结构体变量的输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span>;</span></span><br><span class="line"><span class="comment">//pritnf(&quot;%d&quot;,sizeof(st));</span></span><br><span class="line"><span class="built_in">InpoutStudentInfo</span>(&amp;st);<span class="comment">//对结构体变量的输入</span></span><br><span class="line"><span class="built_in">OutpoutStudentInfo</span>(&amp;st);<span class="comment">//对结构体变量的输出建议用因为参数只传进一个结构体变量的首地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InpoutStudentInfo</span><span class="params">(struct Student * pstu)</span><span class="comment">//pstu占4个字节</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   pstu-&gt;age = <span class="number">10</span>;</span><br><span class="line">   <span class="built_in">strcpy</span>(pstu-&gt;name,<span class="string">&quot;张三&quot;</span>);<span class="comment">//不能写成stu.name=&quot;张三&quot;;不行</span></span><br><span class="line">   pstu-&gt;sex =<span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutpoutStudentInfo</span><span class="params">(struct Student * st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;函数临时开辟的空间大小为%d个字节\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(&amp;st));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;函数临时开辟的空间大小为%d个字节\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(st));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;分数: %d 性别: %c 姓名: %s\n&quot;</span>,st-&gt;age,(*st).sex,st-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、指针变量存放的是变量的首地址的详解</p><p>任何类型的指针变量系统只分配四个字节，指针变量存放的是变量的首地值，例如数组的首地值，结构体变量的首地值，double 类型数据的首地值，任何类型数据的首地地址；首地值即是数据第一个字节的地址编号，每一个字节的地址编号都是 32 位的二进制，这 32 位的地址编号占四个字节，所以系统为指针变量分配四个字节来存储首地值。然后系统会根据不同类型数据的首地址用不同的寻址方式找到数据。<br><img src="/images/6.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大帅哥张茂桃的小女朋友</title>
      <link href="post/7589.html"/>
      <url>post/7589.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/handsomeson/1.gif" alt="大帅哥"><br><img src="/images/handsomeson/3.jpg" width="600px" /></p><h3 id="乘风破浪懒羊羊就是我"><a class="header-anchor" href="#乘风破浪懒羊羊就是我">¶</a>乘风破浪懒羊羊就是我</h3><h4 id="天不生我张茂桃，帅道万古如长夜"><a class="header-anchor" href="#天不生我张茂桃，帅道万古如长夜">¶</a>天不生我张茂桃，帅道万古如长夜</h4><h4 id="诶-你没看见吗，当我拿出这张照片后太阳更辣了，小草更绿了，花儿更红了，就连小鸟也更欢喜了耶"><a class="header-anchor" href="#诶-你没看见吗，当我拿出这张照片后太阳更辣了，小草更绿了，花儿更红了，就连小鸟也更欢喜了耶">¶</a>诶~ 你没看见吗，当我拿出这张照片后太阳更辣了，小草更绿了，花儿更红了，就连小鸟也更欢喜了耶~~</h4><h4 id="上学时，老师讲到“帅”的含义我百思不得其解，这时同学递过来一面镜子我一照，刹那间我明白了。"><a class="header-anchor" href="#上学时，老师讲到“帅”的含义我百思不得其解，这时同学递过来一面镜子我一照，刹那间我明白了。">¶</a>上学时，老师讲到“帅”的含义我百思不得其解，这时同学递过来一面镜子我一照，刹那间我明白了。</h4><h4 id="有一天，我上街，突然一群人把我围住。指着说我帅，我说我不帅，他们就打我，还说我虚伪。"><a class="header-anchor" href="#有一天，我上街，突然一群人把我围住。指着说我帅，我说我不帅，他们就打我，还说我虚伪。">¶</a>有一天，我上街，突然一群人把我围住。指着说我帅，我说我不帅，他们就打我，还说我虚伪。</h4><h4 id="啦啦啦，人见人爱，鸟见鸟呆，风靡万千少女，刺激帅哥市场，挽救无数失足少年，一支梨花压海棠…"><a class="header-anchor" href="#啦啦啦，人见人爱，鸟见鸟呆，风靡万千少女，刺激帅哥市场，挽救无数失足少年，一支梨花压海棠…">¶</a>啦啦啦，人见人爱，鸟见鸟呆，风靡万千少女，刺激帅哥市场，挽救无数失足少年，一支梨花压海棠…</h4><h4 id="最富有才华，英俊潇洒。玉树临风。风流倜傥。高大威猛。人称：山崩地裂，水倒流，鬼见愁，美貌与智慧结合，英雄与侠义化身，人见人爱，花见花开，车见车爆胎"><a class="header-anchor" href="#最富有才华，英俊潇洒。玉树临风。风流倜傥。高大威猛。人称：山崩地裂，水倒流，鬼见愁，美貌与智慧结合，英雄与侠义化身，人见人爱，花见花开，车见车爆胎">¶</a>最富有才华，英俊潇洒。玉树临风。风流倜傥。高大威猛。人称：山崩地裂，水倒流，鬼见愁，美貌与智慧结合，英雄与侠义化身，人见人爱，花见花开，车见车爆胎~</h4><h4 id="一个不帅男人的标志是他愿意为自己的不帅英勇地死去，一个帅男人的标志是他愿意为自己的帅而卑贱地活着，所以，至今我还为自己的帅坚强的活着。"><a class="header-anchor" href="#一个不帅男人的标志是他愿意为自己的不帅英勇地死去，一个帅男人的标志是他愿意为自己的帅而卑贱地活着，所以，至今我还为自己的帅坚强的活着。">¶</a>一个不帅男人的标志是他愿意为自己的不帅英勇地死去，一个帅男人的标志是他愿意为自己的帅而卑贱地活着，所以，至今我还为自己的帅坚强的活着。</h4><h4 id="后记-我死后我千万年，后人类诞生，他们将我的骸骨还原，葬在北极，在我的墓碑上空，终年漂浮着一片云彩，变幻来变幻去，只有一个字-帅…"><a class="header-anchor" href="#后记-我死后我千万年，后人类诞生，他们将我的骸骨还原，葬在北极，在我的墓碑上空，终年漂浮着一片云彩，变幻来变幻去，只有一个字-帅…">¶</a>后记:我死后我千万年，后人类诞生，他们将我的骸骨还原，葬在北极，在我的墓碑上空，终年漂浮着一片云彩，变幻来变幻去，只有一个字:帅…</h4><h4 id="帅不仅仅是男人的痛苦，也是女人的痛苦…我孤老终身…因为…所有的-MM-都自认为配不上我…帅人从不说自己帅，帅人要抓紧时间作帅的样子。"><a class="header-anchor" href="#帅不仅仅是男人的痛苦，也是女人的痛苦…我孤老终身…因为…所有的-MM-都自认为配不上我…帅人从不说自己帅，帅人要抓紧时间作帅的样子。">¶</a>帅不仅仅是男人的痛苦，也是女人的痛苦…我孤老终身…因为…所有的 MM 都自认为配不上我…帅人从不说自己帅，帅人要抓紧时间作帅的样子。</h4><h4 id="帅到，走在街上开车的人看了都会发生交通事故，汽车追尾；路人看了都有迷倒晕倒"><a class="header-anchor" href="#帅到，走在街上开车的人看了都会发生交通事故，汽车追尾；路人看了都有迷倒晕倒">¶</a>帅到，走在街上开车的人看了都会发生交通事故，汽车追尾；路人看了都有迷倒晕倒~~</h4><p><img src="/images/handsomeson/1.gif" alt="大帅哥"></p><!-- <img src="/images/handsomeson/1.jpg" width="300px" /><img src="/images/handsomeson/2.jpg" width="300px" /> --><div class="justified-gallery"><p><img src="https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/gEy5Zc1Ai6VuO4N.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/d6QHbytlSYO4FBG.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/6nepIJ1xTgufatZ.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/E7Jvr4eIPwUNmzq.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/mh19anwBSWIkGlH.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/2tu9JC8ewpBFagv.jpg" alt=""></p>          </div><!-- <div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img" src='https://i.loli.net/2019/11/10/T7Mu8Aod3egmC4Q.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">壁紙</div>  <p>收藏的一些壁紙</p>  <a href='/Gallery/wallpaper'></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img" src='https://i.loli.net/2019/12/25/8t97aVlp4hgyBGu.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">漫威</div>  <p>關於漫威的圖片</p>  <a href='/Gallery/marvel'></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img" src='https://i.loli.net/2019/12/25/hOqbQ3BIwa6KWpo.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">OH MY GIRL</div>  <p>關於OH MY GIRL的圖片</p>  <a href='/Gallery/ohmygirl'></a>  </figcaption>  </figure>  </div> -->]]></content>
      
      
      <categories>
          
          <category> 非人类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 畜生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表的实现</title>
      <link href="post/1c56.html"/>
      <url>post/1c56.html</url>
      
        <content type="html"><![CDATA[<h3 id="单链表"><a class="header-anchor" href="#单链表">¶</a>单链表</h3><ul><li>删除插入结点到指定的 i 位置时要先获取第 i-1 个结点，插入不用判断第 i 个结点是否存在，删除需要判断第 i 个结点是否存在；</li><li>头插法再循环外定义头结点的 next 域为 nullptr，尾插法在循环结束后将最后一个结点的指针域设为 nullptr；</li><li>切记在调用函数时不要传参传错位置 😢 😭 😿 害我找了半天啊~ 💢 💢 💢</li></ul><h4 id="没注释的代码"><a class="header-anchor" href="#没注释的代码">¶</a>没注释的代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">DataType data;</span><br><span class="line">Node&lt;DataType&gt;* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">LinkList</span>();</span><br><span class="line"><span class="built_in">LinkList</span>(DataType a[], <span class="keyword">int</span> e);</span><br><span class="line">~<span class="built_in">LinkList</span>();</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">()</span></span>;<span class="comment">//求单链表长度</span></span><br><span class="line"><span class="function">DataType <span class="title">Get</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Locate</span><span class="params">(DataType x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> i, DataType x)</span></span>;</span><br><span class="line"><span class="function">DataType <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node&lt;DataType&gt;* first;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">LinkList&lt;DataType&gt;::<span class="built_in">LinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">first = <span class="keyword">new</span> Node;</span><br><span class="line">first-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">LinkList&lt;DataType&gt;::<span class="built_in">LinkList</span>(DataType a[], <span class="keyword">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line">first = <span class="keyword">new</span> Node&lt;DataType&gt;;</span><br><span class="line">Node&lt;DataType&gt;* p = first, * s = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line">s = <span class="keyword">new</span> Node&lt;DataType&gt;;</span><br><span class="line">s-&gt;data = a[i];</span><br><span class="line">p-&gt;next = s;</span><br><span class="line">p = s;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//first = new Node&lt;DataType&gt;;</span></span><br><span class="line"><span class="comment">//Node&lt;DataType&gt;* s = nullptr;</span></span><br><span class="line"><span class="comment">//first-&gt;next = nullptr;</span></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; e; i++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">////头插法</span></span><br><span class="line"><span class="comment">//s = new Node&lt;DataType&gt;;</span></span><br><span class="line"><span class="comment">//s-&gt;data = a[i];</span></span><br><span class="line"><span class="comment">//s-&gt;next = first-&gt;next;</span></span><br><span class="line"><span class="comment">//first-&gt;next = s;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">LinkList&lt;DataType&gt;::~<span class="built_in">LinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;DataType&gt;* s = first;</span><br><span class="line"><span class="keyword">while</span> (first != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">first = first-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> s;</span><br><span class="line">s = first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">int</span> LinkList&lt;DataType&gt;::<span class="built_in">Length</span>() &#123;</span><br><span class="line">Node&lt;DataType&gt;* p = first-&gt;next;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">DataType LinkList&lt;DataType&gt;::<span class="built_in">Get</span>(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">DataType x;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">Node&lt;DataType&gt;* p = first;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != <span class="literal">nullptr</span> &amp;&amp; count &lt; i)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">x = p-&gt;data;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">int</span> LinkList&lt;DataType&gt;::<span class="built_in">Locate</span>(DataType x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">Node&lt;DataType&gt;* p = first;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;data == x)</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">void</span> LinkList&lt;DataType&gt;::<span class="built_in">Insert</span>(<span class="keyword">int</span> i, DataType x)</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;DataType&gt;* p = first, * s = <span class="literal">nullptr</span>; <span class="comment">//工作指针p初始化</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; count &lt; i - <span class="number">1</span>)  <span class="comment">//查找第i – 1个结点</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next; <span class="comment">//工作指针p后移</span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span><span class="string">&quot;位置错误&quot;</span>; <span class="comment">//没有找到第i – 1个结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">s = <span class="keyword">new</span> Node&lt;DataType&gt;;</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">DataType LinkList&lt;DataType&gt;::<span class="built_in">Delete</span>(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">DataType x;</span><br><span class="line">Node&lt;DataType&gt;* p = first, * r = <span class="literal">nullptr</span>;   <span class="comment">//工作指针p指向头结点</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; count &lt; i - <span class="number">1</span>) <span class="comment">//查找第i-1个结点</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">nullptr</span> || p-&gt;next == <span class="literal">nullptr</span>)<span class="comment">//结点p不存在或p的后继结点不存在</span></span><br><span class="line"><span class="keyword">throw</span><span class="string">&quot;位置错误&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">r = p-&gt;next;</span><br><span class="line">x = r-&gt;data;</span><br><span class="line">p-&gt;next = r-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">bool</span> LinkList&lt;DataType&gt;::<span class="built_in">Empty</span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (first-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">void</span> LinkList&lt;DataType&gt;::<span class="built_in">PrintList</span>()</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;DataType&gt;* p = first-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;, i, x;</span><br><span class="line">LinkList&lt;<span class="keyword">int</span>&gt; L&#123; r, <span class="number">5</span> &#125;;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前线性表的数据为：&quot;</span>;</span><br><span class="line">L.<span class="built_in">PrintList</span>();                         <span class="comment">//输出当前链表1 2 3 4 5</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">L.<span class="built_in">Insert</span>(<span class="number">2</span>, <span class="number">8</span>);                         <span class="comment">//在第2个位置插入值为8的结点</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;执行插入操作后数据为：&quot;</span>;</span><br><span class="line">L.<span class="built_in">PrintList</span>();                         <span class="comment">//输出插入后链表1 8 2 3 4 5</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">char</span>* str) &#123;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前单链表的长度为：&quot;</span> &lt;&lt; L.<span class="built_in">Length</span>() &lt;&lt; endl;      <span class="comment">//输出单链表长度6</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入查找的元素值：&quot;</span>;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">i = L.<span class="built_in">Locate</span>(x);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> &lt;= i) cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;的元素位置为：&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;单链表中没有元素&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入要删除第几个元素：&quot;</span>;</span><br><span class="line">cin &gt;&gt; i;</span><br><span class="line">x = L.<span class="built_in">Delete</span>(i);                                 <span class="comment">//删除第i个元素</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;删除的元素值是&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;执行删除操作后数据为：&quot;</span>;</span><br><span class="line">L.<span class="built_in">PrintList</span>();                                 <span class="comment">//输出删除后链表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">char</span>* str) &#123;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有注释的代码"><a class="header-anchor" href="#有注释的代码">¶</a>有注释的代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>                  <span class="comment">//引入输入输出流</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DataType data;               <span class="comment">//数据域</span></span><br><span class="line">    Node&lt;DataType&gt;* next;       <span class="comment">//指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkList</span>();                      <span class="comment">//无参构造函数，建立只有头结点的空链表</span></span><br><span class="line">    <span class="built_in">LinkList</span>(DataType a[], <span class="keyword">int</span> n);       <span class="comment">//有参构造函数，建立有n个元素的单链表</span></span><br><span class="line">    ~<span class="built_in">LinkList</span>();                     <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">()</span></span>;                     <span class="comment">//求单链表的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Empety</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">DataType <span class="title">Get</span><span class="params">(<span class="keyword">int</span> i)</span></span>;               <span class="comment">//按位查找。查找第i个结点的元素值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Locate</span><span class="params">(DataType x)</span></span>;            <span class="comment">//按值查找。查找值为x的元素序号</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> i, DataType x)</span></span>;       <span class="comment">//插入操作，第i个位置插入值为x的结点</span></span><br><span class="line">    <span class="function">DataType <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> i)</span></span>;            <span class="comment">//删除操作，删除第i个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">()</span></span>;                  <span class="comment">//遍历操作，按序号依次输出各元素</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;DataType&gt;* first;           <span class="comment">//单链表的头指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">LinkList&lt;DataType&gt; ::<span class="built_in">LinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    first = <span class="keyword">new</span> Node&lt;DataType&gt;;              <span class="comment">//生成头结点</span></span><br><span class="line">    first-&gt;next = <span class="literal">nullptr</span>;                      <span class="comment">//头结点的指针域置空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">DataType</span>&gt;</span></span><br><span class="line">LinkList&lt;DataType&gt; :: ~<span class="built_in">LinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;DataType&gt;* q = first;       <span class="comment">//暂存被释放结点</span></span><br><span class="line">    <span class="keyword">while</span> (first != <span class="literal">nullptr</span>)        <span class="comment">//释放单链表的每一个结点的存储空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// q = first;</span></span><br><span class="line">        first = first-&gt;next;         <span class="comment">// first指向被释放结点的下一个结点</span></span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">        q = first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">int</span> LinkList&lt;DataType&gt; ::<span class="built_in">Empety</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (first-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">void</span> LinkList&lt;DataType&gt; ::<span class="built_in">PrintList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;DataType&gt;* p = first-&gt;next;                <span class="comment">//工作指针p初始化</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        p = p-&gt;next;                 <span class="comment">//工作指针p后移，注意不能写作p++</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">int</span> LinkList&lt;DataType&gt; ::<span class="built_in">Length</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;DataType&gt;* p = first-&gt;next;   <span class="comment">//工作指针p初始化为开始接点</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;                    <span class="comment">//累加器count初始化</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;              <span class="comment">//注意count的初始化和返回值之间的关系</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">DataType LinkList&lt;DataType&gt; ::<span class="built_in">Get</span>(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;DataType&gt;* p = first-&gt;next;    <span class="comment">//工作指针p初始化</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;                     <span class="comment">//累加器count初始化</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; count &lt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;                   <span class="comment">//工作指针p后移</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="keyword">throw</span> <span class="string">&quot;位置&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">int</span> LinkList&lt;DataType&gt; ::<span class="built_in">Locate</span>(DataType x)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;DataType&gt;* p = first-&gt;next;   <span class="comment">//工作指针p初始化</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;                     <span class="comment">//累加器count初始化</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == x) <span class="keyword">return</span> count;     <span class="comment">//查找成功，结束函数并返回序号</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                        <span class="comment">//退出循环表明查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">void</span> LinkList&lt;DataType&gt; ::<span class="built_in">Insert</span>(<span class="keyword">int</span> i, DataType x)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;DataType&gt;* p = first, * s = <span class="literal">nullptr</span>;        <span class="comment">//工作指针p初始化</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; count &lt; i - <span class="number">1</span>)            <span class="comment">//查找第i – 1个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;                              <span class="comment">//工作指针p后移</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="keyword">throw</span> <span class="string">&quot;位置&quot;</span>;        <span class="comment">//没有找到第i – 1个结点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        s = <span class="keyword">new</span> Node&lt;DataType&gt;; s-&gt;data = x;      <span class="comment">//申请结点s，数据域为x</span></span><br><span class="line">        s-&gt;next = p-&gt;next; p-&gt;next = s;     <span class="comment">//将结点s插入到结点p之后</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头插法构造</span></span><br><span class="line"><span class="comment">//template &lt;typename DataType&gt;</span></span><br><span class="line"><span class="comment">//LinkList&lt;DataType&gt; :: LinkList(DataType a[ ], int n)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//first = new Node&lt;DataType&gt;; first-&gt;next = nullptr;     //初始化一个空链表</span></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; n; i++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//Node&lt;DataType&gt; *s;</span></span><br><span class="line"><span class="comment">//s = new Node&lt;DataType&gt;; s-&gt;data = a[i];</span></span><br><span class="line"><span class="comment">// s-&gt;next = first-&gt;next; first-&gt;next = s;    //将结点s插入到头结点之后</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">LinkList&lt;DataType&gt; ::<span class="built_in">LinkList</span>(DataType a[], <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    first = <span class="keyword">new</span> Node&lt;DataType&gt;;                    <span class="comment">//生成头结点</span></span><br><span class="line">    Node&lt;DataType&gt;* r = first, * s = <span class="literal">nullptr</span>;           <span class="comment">//尾指针初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s = <span class="keyword">new</span> Node&lt;DataType&gt;;</span><br><span class="line">        s-&gt;data = a[i];</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;                 <span class="comment">//将结点s插入到终端结点之后</span></span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">nullptr</span>;        <span class="comment">//单链表建立完毕，将终端结点的指针域置空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template &lt;typename DataType&gt;</span></span><br><span class="line"><span class="comment">LinkList&lt;DataType&gt; ::LinkList(DataType a[], int n)//头插法</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    first = new Node&lt;DataType&gt;;                    //生成头结点</span></span><br><span class="line"><span class="comment">    Node&lt;DataType&gt;* r = first, * s = nullptr;           //尾指针初始化</span></span><br><span class="line"><span class="comment">    r-&gt;next = NULL;</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; n; i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        s = new Node&lt;DataType&gt;;</span></span><br><span class="line"><span class="comment">        s-&gt;data = a[i];</span></span><br><span class="line"><span class="comment">        s-&gt;next = r-&gt;next;</span></span><br><span class="line"><span class="comment">        r-&gt;next = s;</span></span><br><span class="line"><span class="comment">                         //将结点s插入到终端结点之后</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  //  r-&gt;next = nullptr;        //单链表建立完毕，将终端结点的指针域置空</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">DataType LinkList&lt;DataType&gt; ::<span class="built_in">Delete</span>(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    DataType x;</span><br><span class="line">    Node&lt;DataType&gt;* p = first, * q = <span class="literal">nullptr</span>;        <span class="comment">//工作指针p指向头结点</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; count &lt; i - <span class="number">1</span>)           <span class="comment">//查找第i-1个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || p-&gt;next == <span class="literal">nullptr</span>)  <span class="comment">//结点p不存在或p的后继结点不存在</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;位置错误&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        q = p-&gt;next; x = q-&gt;data;         <span class="comment">//暂存被删结点</span></span><br><span class="line">        p-&gt;next = q-&gt;next;              <span class="comment">//摘链</span></span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;, i, x;</span><br><span class="line">    LinkList&lt;<span class="keyword">int</span>&gt; L&#123; r, <span class="number">5</span> &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;当前线性表的数据为：&quot;</span>;</span><br><span class="line">    L.<span class="built_in">PrintList</span>();                         <span class="comment">//输出当前链表1 2 3 4 5</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        L.<span class="built_in">Insert</span>(<span class="number">2</span>, <span class="number">8</span>);                         <span class="comment">//在第2个位置插入值为8的结点</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;执行插入操作后数据为：&quot;</span>;</span><br><span class="line">        L.<span class="built_in">PrintList</span>();                         <span class="comment">//输出插入后链表1 8 2 3 4 5</span></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">char</span>* str) &#123;</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;当前单链表的长度为：&quot;</span> &lt;&lt; L.<span class="built_in">Length</span>() &lt;&lt; endl;      <span class="comment">//输出单链表长度6</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入查找的元素值：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    i = L.<span class="built_in">Locate</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> &lt;= i) cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;的元素位置为：&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;单链表中没有元素&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入要删除第几个元素：&quot;</span>;</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">        x = L.<span class="built_in">Delete</span>(i);                                 <span class="comment">//删除第i个元素</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;删除的元素值是&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;执行删除操作后数据为：&quot;</span>;</span><br><span class="line">        L.<span class="built_in">PrintList</span>();                                 <span class="comment">//输出删除后链表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">char</span>* str) &#123;</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTMl5 新增标签</title>
      <link href="post/90a4.html"/>
      <url>post/90a4.html</url>
      
        <content type="html"><![CDATA[<h3 id="web-前端：main、header、footer、nav、article、section-标签的用法"><a class="header-anchor" href="#web-前端：main、header、footer、nav、article、section-标签的用法">¶</a>web 前端：main、header、footer、nav、article、section 标签的用法</h3><hr><blockquote><p>HTML5<br>添加了诸如 main、header、footer、nav、article、section 等大量新标签，这些新标签为开发人员提供更多的选择和辅助特性。<br>默认情况下，浏览器呈现这些新标签的方式与 div 相似。然而，合理地使用它们，可以使你的标签更加的语义化。辅助技术（如：屏幕阅读器）可以通过这&gt; 些标签为用户提供更加准确的、易于理解的页面信息。</p></blockquote><h4 id="标签-main"><a class="header-anchor" href="#标签-main">¶</a><strong>标签 main</strong></h4><p>​ main 标签用于呈现网页的主体内容，且每个页面只能有一个。这意味着它只应包含与页面中心主题相关的信息，而不应包含如导航连接、网页横幅等可以在多个页面中重复出现的内容。main 标签的语义化特性可以使辅助技术快速定位到页面的主体。有些页面中有 “跳转到主要内容” 的链接，使用 main 标签可以使辅助设备自动获得这个功能。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Weapons of the Ninja<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span>//网页的主体内容<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">//main标签应该在header标签与footer标签之间。</span><br></pre></td></tr></table></figure><h4 id="标签-article"><a class="header-anchor" href="#标签-article">¶</a><strong>标签 article</strong></h4><p>​ article 是另一个具有语义化特性的 HTML5 新标签。article 是一个分段标签，用于呈现独立及完整的内容。这个标签适用于博客入口、论坛帖子或者新闻文。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Deep Thoughts with Master Camper Cat<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>The Garfield Files: Lasagna as Training Fuel?<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">The internet is littered with varying opinions on nutritional</span><br><span class="line">paradigms, from catnip paleo to hairball cleanses. But let&#x27;s turn</span><br><span class="line">our attention to an often overlooked fitness fuel, and examine the</span><br><span class="line">protein-carb-NOM trifecta that is lasagna...</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">//用于呈现独立及完整的内容</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;samuraiSwords.jpeg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Defeating your Foe: the Red Dot is Ours!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">Felines the world over have been waging war on the most persistent</span><br><span class="line">of foes. This red nemesis combines both cunning stealth and</span><br><span class="line">lightening speed. But chin up, fellow fighters, our time for victory</span><br><span class="line">may soon be near...</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;samuraiSwords.jpeg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Is Chuck Norris a Cat Person?<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">Chuck Norris is widely regarded as the premier martial artist on the</span><br><span class="line">planet, and it&#x27;s a complete coincidence anyone who disagrees with</span><br><span class="line">this fact mysteriously disappears soon after. But the real question</span><br><span class="line">is, is he a cat person?...</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="请注意-section-和-div-的区别："><a class="header-anchor" href="#请注意-section-和-div-的区别：">¶</a><strong>请注意 section 和 div 的区别：</strong></h5><p>​ section 也是一个 HTML5 新标签，与 article 标签的语义含义略有不同。article 用于独立的、完整的内容，而 section 用于对与主题相关的内容进行分组。它们可以根据需要嵌套着使用。举个例子：如果一本书是一个 article 的话，那么每个章节就是 section。当内容组之间没有联系时，可以使用 div。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">- 内容组</span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">- 有联系的内容组</span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span>- 独立完整的内容<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="标签-header"><a class="header-anchor" href="#标签-header">¶</a><strong>标签 header</strong></h4><p>header 也是一个具有语义化的、提升页面可访问性的 HTML5 标签。它可以为父级标签呈现简介信息或者导航链接，适用于那些在多个页面顶部重复出现的内容。</p><p>与 main 类似，header 的语义化特性也可以使辅助技术快速定位到它的内容。</p><h5 id="注意：-header-用在-HTML-文档的-body-标签中。这点与包含页面标题、元信息的-head-标签不同。"><a class="header-anchor" href="#注意：-header-用在-HTML-文档的-body-标签中。这点与包含页面标题、元信息的-head-标签不同。">¶</a><strong>注意</strong>： header 用在 HTML 文档的 body 标签中。这点与包含页面标题、元信息的 head 标签不同。</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Training with Camper Cat<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">//适用于那些在多个页面顶部重复出现的内容，导航或简介信息</span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;stealth&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Stealth <span class="symbol">&amp;amp;</span> Agility Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><br><span class="line">Climb foliage quickly using a minimum spanning tree approach</span><br><span class="line"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>No training is NP-complete without parkour<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;combat&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Combat Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Dispatch multiple enemies with multithreaded tactics<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Goodbye world: 5 proven ways to knock out an opponent<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;weapons&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Weapons Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Swords: the best tool to literally divide and conquer<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Breadth-first or depth-first in multi-weapon training?<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="标签-nav"><a class="header-anchor" href="#标签-nav">¶</a><strong>标签 nav</strong></h4><p>nav 也是一个具有语义化特性的 HTML5 标签，用于呈现页面中的主导航链接。它可以使屏幕阅读器快速识别页面中的导航信息。对于页面底部辅助性质的站点链接，不需要使用 nav，用 footer 会更好。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Training with Camper Cat<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#stealth&quot;</span>&gt;</span>Stealth <span class="symbol">&amp;amp;</span> Agility<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#combat&quot;</span>&gt;</span>Combat<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#weapons&quot;</span>&gt;</span>Weapons<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">//用于呈现页面中的主导航链接</span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;stealth&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Stealth <span class="symbol">&amp;amp;</span> Agility Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><br><span class="line">Climb foliage quickly using a minimum spanning tree approach</span><br><span class="line"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>No training is NP-complete without parkour<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;combat&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Combat Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Dispatch multiple enemies with multithreaded tactics<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Goodbye world: 5 proven ways to knock out an opponent<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;weapons&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Weapons Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Swords: the best tool to literally divide and conquer<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Breadth-first or depth-first in multi-weapon training?<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="标签-footer"><a class="header-anchor" href="#标签-footer">¶</a><strong>标签 footer</strong></h4><p>​ 与 header 和 nav 类似，footer 也具有语义化特性，可以使辅助设备快速定位到它。它位于页面底部，用于呈现版权信息或者相关文档链接。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Training<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#stealth&quot;</span>&gt;</span>Stealth <span class="symbol">&amp;amp;</span> Agility<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#combat&quot;</span>&gt;</span>Combat<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#weapons&quot;</span>&gt;</span>Weapons<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;stealth&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Stealth <span class="symbol">&amp;amp;</span> Agility Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><br><span class="line">Climb foliage quickly using a minimum spanning tree approach</span><br><span class="line"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>No training is NP-complete without parkour<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;combat&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Combat Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Dispatch multiple enemies with multithreaded tactics<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Goodbye world: 5 proven ways to knock out an opponent<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;weapons&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Weapons Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Swords: the best tool to literally divide and conquer<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Breadth-first or depth-first in multi-weapon training?<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="symbol">&amp;copy;</span> 2016 Camper Cat<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">//用于呈现版权信息或者相关文档链接</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
