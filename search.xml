<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>队列的两种实现方式</title>
      <link href="post/c2ed.html"/>
      <url>post/c2ed.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="队列的链式实现-koala"><a href="#队列的链式实现-koala" class="headerlink" title="队列的链式实现 :koala:"></a>队列的链式实现 :koala:</h4><ul><li>:sunflower: 链队的初始化实现采用的是不带头结点的方法，前边链式实现顺序表和栈时用的带头结点的方法，这次用不带头结点的方法，一是多掌握，二是考试考到可以做快。:cloud:<ul><li>  初始化队列时由于不带头指针，在第一个位置加了一个 if()判断，区别于后边结点的插法。:sheep:</li><li>  由于头指针和尾指针都是指向相同类型的结构体，把两个指针定义到同一个结构体中，否则，还要在 main()函数中定义头指针和尾指针，然后传入函数中操作，形参也要多定义一个。</li><li>  由于没定义头结点，只能定义指针，在形参中一定注意使用引用</li></ul></li></ul><ul><li>:heavy_plus_sign: 自我反省<ul><li>  :warning: 自己做的时候在定义出队函数时没注意，然后运行时发现连续出队两次就报错,调试半天才发现在形参中未定义引用类型。再复习一次关于结点与指针是否使用引用 :warning:</li><li>  因为不定义引用类型，如果传进去的是个结点，系统在内存中开辟一片区域，里面存有和传入节点一样的 data，一样的 next，因为形参结点带有传入结点的 next 指针域，对复制的结点操作一样能改变原结点后边的结点。如果是指针的话，传入的是指针指向的地址，指针操作了结点后，不改变原来 main()函数的指针指向的地址，如果没对结点进行增删，再次调用函数，不会对原队列有影响，否则，传入的指针的会找不到指向的位置。定义了引用类型，上边的错误就不会存在。</li><li>  详情参考 <code> bool DeQueue() ,EleType GetTop(),void Print(),string IsEmpty()</code>这四个函数形参的定义。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EleType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">EleType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;*LinkNode;</span><br><span class="line"><span class="comment">//将头指针尾指针放入一个结构体中</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">LinkNode front, rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">( LinkQueue&amp; r, EleType x)</span> </span>&#123;</span><br><span class="line">LinkNode q = r.rear, s;</span><br><span class="line">s = <span class="keyword">new</span> Node;</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">s-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">q-&gt;next = s;</span><br><span class="line">q = q-&gt;next;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;r, EleType&amp; x)</span> </span>&#123;</span><br><span class="line">LinkNode q;</span><br><span class="line"><span class="keyword">if</span> (r.front == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">x = <span class="number">999999999</span>;<span class="comment">//如果x打印为999999999表示链队列为空。</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">x = r.front-&gt;data;</span><br><span class="line">q = r.front;</span><br><span class="line">r.front = r.front-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> q;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="function">LinkNode <span class="title">InitQueue</span><span class="params">(LinkNode&amp; L, LinkQueue&amp; r, EleType a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*L = new Node;*/</span></span><br><span class="line">L = <span class="literal">nullptr</span>;</span><br><span class="line">LinkNode s;</span><br><span class="line">r.front = L;</span><br><span class="line">r.rear = L;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">s = <span class="keyword">new</span> Node;</span><br><span class="line">s-&gt;data = a[i];</span><br><span class="line">s-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">r.rear = s;</span><br><span class="line">s-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">r.front = r.rear;</span><br><span class="line">L = r.rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">r.rear-&gt;next = s;</span><br><span class="line">r.rear = s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取队头元素</span></span><br><span class="line"><span class="function">EleType <span class="title">GetTop</span><span class="params">(LinkQueue r)</span> </span>&#123;</span><br><span class="line">EleType x;</span><br><span class="line"><span class="keyword">if</span> (r.front == <span class="literal">nullptr</span>) <span class="comment">//记得加条件判断当前栈是否为空，否则当队列为空时，出队会出错。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">x = r.front-&gt;data;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function">string <span class="title">IsEmpty</span><span class="params">( LinkQueue r)</span> </span>&#123;</span><br><span class="line">string text;</span><br><span class="line"><span class="keyword">if</span> (r.front == <span class="literal">nullptr</span>)</span><br><span class="line">text = <span class="string">&quot;队列为空&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">text = <span class="string">&quot;队列不为空&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">( LinkQueue r)</span> </span>&#123;</span><br><span class="line">LinkNode s=r.front;</span><br><span class="line"><span class="keyword">while</span> (s!=<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; s-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">s = s-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LinkNode L;</span><br><span class="line">LinkQueue r;</span><br><span class="line">EleType x;</span><br><span class="line"><span class="comment">/*EleType a[] = &#123; 1,2,3,999,888,555 &#125;;*/</span></span><br><span class="line">EleType a[] = &#123; <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">InitQueue</span>(L, r, a, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">Print</span>(r);</span><br><span class="line">cout &lt;&lt; <span class="built_in">IsEmpty</span>( r) &lt;&lt; endl;</span><br><span class="line"><span class="built_in">GetTop</span>(r);</span><br><span class="line"><span class="built_in">EnQueue</span>( r, <span class="number">55</span>);</span><br><span class="line"><span class="built_in">Print</span>(r);</span><br><span class="line"><span class="built_in">DeQueue</span>( r, x);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"><span class="built_in">DeQueue</span>(r, x);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"><span class="built_in">DeQueue</span>(r, x);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="顺序队列的实现-partly-sunny"><a href="#顺序队列的实现-partly-sunny" class="headerlink" title="顺序队列的实现 :partly_sunny:"></a>顺序队列的实现 :partly_sunny:</h4><ul><li><p>  由于顺序队列采用一般的数组的话，当出队入队多进行几次，就会出现上溢。:goat:</p></li><li><p>  采用循环数组可以提高空间利用率。:clown_face:</p></li><li><p>  核心是操作数组下标时，要采用取余的方式。:crown:</p></li><li><p>头指针指向第一个元素的位置，尾指针指向最后一个元素的位置，有三种判断队列是否为空，满的方式。:game_die:</p><ul><li>  牺牲一个存储单元来判断队列是否为满，队满 L.rear + 1) % MaxSize == L.front % MaxSize；队空 L.front % MaxSize == L.rear % MaxSize；</li><li>  增加一个变量存储当前的队列长度，就不用牺牲存储单元，length=0，空；length=MaxSize 满。</li><li>  增加一个 flag 变量，如果出队就改变 flag = -1，入队 flag = 0。在判断 front == rear 时，flag = -1 队空，flag = 0 队满。</li></ul></li><li><p>  头指针尾指针的位置并不是固定放在某个位置，看具体的题，具体判断。:white_flower:</p></li></ul><ul><li>自我反省关于多次调用 Print()函数出现错误 :cry:<ul><li>  :warning: 由于在 Print() 定义了引用变量，导致多次打印数组错误，对链式的数据结构，采用定义引用形参打印时没影响，静态数据结构用引用就会影响！:warning:</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EleType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">EleType data[MaxSize];</span><br><span class="line"><span class="keyword">int</span> front;</span><br><span class="line"><span class="keyword">int</span> rear;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line">&#125;SeqQueue;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SeqQueue&amp; L)</span> </span>&#123;</span><br><span class="line"><span class="comment">//顺序循环队列初始化将头指针和尾指针同时指向数组高端</span></span><br><span class="line"><span class="comment">//头指针指向第一个元素前的位置，尾指针指向最后一个元素的位置</span></span><br><span class="line">L.front = <span class="number">0</span>; <span class="comment">// front 指向队头元素</span></span><br><span class="line">L.rear = <span class="number">0</span>;  <span class="comment">// rear 指向队尾元素</span></span><br><span class="line">L.length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">while</span> (x != <span class="number">999</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (L.length &lt;= MaxSize)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">L.data[L.rear % MaxSize] = x;</span><br><span class="line">L.rear = (L.rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">&#125;</span><br><span class="line">L.length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(SeqQueue&amp; L)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L.rear == L.front - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryQueue</span><span class="params">(SeqQueue&amp; L)</span> </span>&#123;</span><br><span class="line">L.front = L.rear = MaxSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SeqQueue&amp; L, <span class="keyword">int</span>  x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((L.rear + <span class="number">1</span>) % MaxSize == L.front % MaxSize)<span class="comment">//牺牲一个存储单元来判断队列是否为满，队满，L.rear+1 = L.front；</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//if (L.length == MaxSize)//增加一个变量存储当前的队列长度，就不用牺牲存储单元</span></span><br><span class="line"><span class="comment">//return false;</span></span><br><span class="line"><span class="comment">//if (L.front % MaxSize == L.rear%MaxSize &amp;&amp; L.falg == -1)//增加一个变量存储最后一次的操作是出队还是入队，就不用牺牲存储单元</span></span><br><span class="line"><span class="comment">//return false;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">L.data[L.rear] = x;</span><br><span class="line">L.rear = (L.rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">L.length++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SeqQueue&amp; L, <span class="keyword">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L.front % MaxSize == L.rear % MaxSize)<span class="comment">//牺牲一个存储单元来判断队列是否为满，队空，和初始化一样，L.frontt = L.rear;</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//if (L.length == 0)//增加一个变量存储当前的队列长度，就不用牺牲存储单元</span></span><br><span class="line"><span class="comment">//return false;</span></span><br><span class="line"><span class="comment">//if (L.front % MaxSize == L.rear%MaxSize &amp;&amp; L.falg == -1)//增加一个变量存储最后一次的操作是出队还是入队，就不用牺牲存储单元</span></span><br><span class="line"><span class="comment">//return false;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">x = L.data[L.front];</span><br><span class="line">L.front = (L.front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">&#125;</span><br><span class="line">L.length--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">EleType <span class="title">GetHead</span><span class="params">(SeqQueue&amp; L, EleType&amp; x)</span> </span>&#123;</span><br><span class="line">x = L.data[L.front];</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(SeqQueue L)</span> </span>&#123;</span><br><span class="line">EleType num;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">num = (L.front) % MaxSize;</span><br><span class="line">cout &lt;&lt; L.data[num] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">L.front = (L.front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SeqQueue L = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">InitQueue</span>(L);</span><br><span class="line"><span class="built_in">Print</span>(L);</span><br><span class="line"><span class="built_in">EnQueue</span>(L, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">Print</span>(L);</span><br><span class="line"><span class="built_in">DeQueue</span>(L, x);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;出队元素：&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序表的动态扩容</title>
      <link href="post/5e54.html"/>
      <url>post/5e54.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="顺序表的动态扩容"><a href="#顺序表的动态扩容" class="headerlink" title="顺序表的动态扩容"></a>顺序表的动态扩容</h4><ul><li><p>插入操作判断位置是否合法(位置取值范围在 1~length+1），另外还要判断当前表是否为满(L.length &gt;= L.MaxSize)。 :dancer:</p><ul><li><p>  把每个元素往后移动一位，直到输入的插入的位置 ​ :muscle::muscle::muscle:。</p></li><li><p>  第 n 个位置对应的值在数组中的值为 data[n-1]。</p></li><li><p>  代码操作如下：</p></li></ul>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertList</span><span class="params">(SeqList L, <span class="keyword">int</span> i, <span class="keyword">int</span> e)</span> <span class="comment">//插入操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (L.length &gt;= L.MaxSize)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = L.length; j &gt;= i; j--)</span><br><span class="line">  &#123;</span><br><span class="line">    L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  L.data[i - <span class="number">1</span>] = e;</span><br><span class="line">  L.length++;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除操作判断位置是否合法（位置取值范围 1~length），另外还要判断当前表是否为空 L.length &lt;= 0。:rooster: ​</p><ul><li><p>  取出删除位置的元素，然后把每个元素往前移动一位，直到输入的删除的位置。:dog:</p></li><li><p>  第 n 个位置对应的值在数组中的值为 data[n-1]。</p></li><li><p>  代码操作如下：</p></li></ul>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteList</span><span class="params">(SeqList L, <span class="keyword">int</span> i, <span class="keyword">int</span> &amp;e)</span> <span class="comment">//删除操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (L.length &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  e = L.data[i - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; L.length; j--)</span><br><span class="line">  &#123;</span><br><span class="line">    L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  L.length--;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>  :cake: :play_or_pause_button:</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> *data;</span><br><span class="line"><span class="keyword">int</span> MaxSize;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line">&#125; SeqList;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SeqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">L.data = <span class="keyword">new</span> <span class="keyword">int</span>[InitSize];</span><br><span class="line">L.MaxSize = InitSize;</span><br><span class="line">L.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IncreaseList</span><span class="params">(SeqList L, <span class="keyword">int</span> len)</span> <span class="comment">//动态扩容</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = L.data;</span><br><span class="line">L.data = <span class="keyword">new</span> <span class="keyword">int</span>[(L.MaxSize + len)];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">  L.data[i] = p[i];</span><br><span class="line">&#125;</span><br><span class="line">L.MaxSize = L.MaxSize + len;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertList</span><span class="params">(SeqList L, <span class="keyword">int</span> i, <span class="keyword">int</span> e)</span> <span class="comment">//插入操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (L.length &gt;= L.MaxSize)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = L.length; j &gt;= i; j--)</span><br><span class="line">&#123;</span><br><span class="line">  L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">L.data[i - <span class="number">1</span>] = e;</span><br><span class="line">L.length++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//length=位置</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteList</span><span class="params">(SeqList L, <span class="keyword">int</span> i, <span class="keyword">int</span> &amp;e)</span> <span class="comment">//删除操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (L.length &lt;= <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">e = L.data[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; L.length; j--)</span><br><span class="line">&#123;</span><br><span class="line">  L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">L.length--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLocate</span><span class="params">(SeqList L, <span class="keyword">int</span> e)</span> <span class="comment">//按值查找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">  <span class="keyword">if</span> (L.data[i] == e)</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElement</span><span class="params">(SeqList L, <span class="keyword">int</span> i)</span> <span class="comment">//按位查找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Put</span><span class="params">(SeqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, L.data[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SeqList L;</span><br><span class="line"><span class="built_in">InitList</span>(L);</span><br><span class="line"><span class="built_in">InsertList</span>(L, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">InsertList</span>(L, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">InsertList</span>(L, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">Put</span>(L);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈的两种实现方式</title>
      <link href="post/e2a9.html"/>
      <url>post/e2a9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="raised-hands-顺序栈-raised-hands"><a href="#raised-hands-顺序栈-raised-hands" class="headerlink" title=":raised_hands: 顺序栈 :raised_hands:"></a>:raised_hands: 顺序栈 :raised_hands:</h4><ul><li>  Push()函数判满 -&gt; 顺序栈用的是数组，下标从 0 开始，top = MaxSize-1 ; 栈满 ; :rocket:</li><li>  Pop()函数判空 -&gt; 顺序栈用的是数组，下标从 0 开始，top = -1;栈空; :rocket:</li><li>  Print()函数遍历打印完全 -&gt; top 相当于数组的下标，i&lt;S.top 才能把栈遍历完全。:rocket:</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EleType;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">EleType data[MaxSize];</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line">&#125;SeqStack;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SeqStack&amp; S)</span> </span>&#123;</span><br><span class="line">S.top = <span class="number">-1</span>;</span><br><span class="line">S.length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">while</span> (x != <span class="number">999</span>&amp;&amp; S.length &lt; MaxSize) &#123; <span class="comment">//用length&lt;MaxSize 确保构造的栈不会溢出</span></span><br><span class="line">S.data[++S.top] = x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">S.length++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SeqStack&amp; S, EleType x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == MaxSize - <span class="number">1</span>)<span class="comment">//顺序栈用的是数组，下标从0开始，top = MaxSize-1;栈满;</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">S.data[++S.top] = x;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SeqStack&amp; S, EleType&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == <span class="number">-1</span>)<span class="comment">//顺序栈用的是数组，下标从0开始，top = -1;栈空;</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x = S.data[S.top--];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(SeqStack&amp; S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= S.top; i++)<span class="comment">//top相当于数组的下标，i&lt;S.top 才能把栈遍历完全。</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; S.data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">SeqStack S = &#123;&#125;;</span><br><span class="line"><span class="built_in">InitStack</span>(S);</span><br><span class="line"><span class="built_in">Push</span>(S, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">Print</span>(S);</span><br><span class="line"><span class="built_in">Pop</span>(S, x);</span><br><span class="line"><span class="built_in">Print</span>(S);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="elephant-栈的链式存储-elephant"><a href="#elephant-栈的链式存储-elephant" class="headerlink" title=":elephant: 栈的链式存储 :elephant:"></a>:elephant: 栈的链式存储 :elephant:</h3><ul><li>  下边代码用的是带头结点的写法，题中如果说明了要用未带头结点的写法，要注意。 :cry:</li><li>  链栈初始化和链表初始化一样。:satisfied:</li><li>  入栈出栈在头结点后操作。 :alien:</li></ul><h4 id="自我反省"><a href="#自我反省" class="headerlink" title="自我反省"></a>自我反省</h4><ul><li>  出栈要判断栈是否为空，取栈顶元素也要判断栈顶是否为空(:warning: 在第一次写时就没有在 GetTop()函数中判断 :warning: )</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EleType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">EleType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Stack, * LinkStack;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(LinkStack&amp; L, EleType x)</span> </span>&#123;</span><br><span class="line">LinkStack r = L-&gt;next, s;</span><br><span class="line">s = <span class="keyword">new</span> Node;</span><br><span class="line">s-&gt;next = r;</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">L-&gt;next = s;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(LinkStack&amp; L, EleType&amp; x)</span> </span>&#123;</span><br><span class="line">LinkStack r = L-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (r == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">x = <span class="number">999999999</span>; <span class="comment">//如果x打印为999999999表示链栈为空。</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">x = r-&gt;data;</span><br><span class="line">L-&gt;next = r-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> r;</span><br><span class="line">r = L-&gt;next;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Stack* <span class="title">InitStack</span><span class="params">(LinkStack&amp; L)</span> </span>&#123;</span><br><span class="line">L = <span class="keyword">new</span> Node;</span><br><span class="line">L-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">LinkStack s, r = L;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">while</span> (x != <span class="number">999</span>) &#123;</span><br><span class="line">s = <span class="keyword">new</span> Node;</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">s-&gt;next = r-&gt;next;</span><br><span class="line">r-&gt;next = s;</span><br><span class="line">r = r-&gt;next;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">EleType <span class="title">GetTop</span><span class="params">(LinkStack&amp; L)</span> </span>&#123;</span><br><span class="line">EleType x;</span><br><span class="line">LinkStack r = L-&gt;next;</span><br><span class="line">  <span class="keyword">if</span> (r == <span class="literal">nullptr</span>) <span class="comment">//记得加条件判断当前栈是否为空，否则当栈为空时，出栈会出错。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">x = r-&gt;data;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LinkStack L;</span><br><span class="line">EleType x;</span><br><span class="line"><span class="built_in">InitStack</span>(L);</span><br><span class="line"><span class="built_in">GetTop</span>(L);</span><br><span class="line"><span class="built_in">Push</span>(L, <span class="number">55</span>);</span><br><span class="line"><span class="built_in">Pop</span>(L, x);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形参指针变量和引用</title>
      <link href="post/7394.html"/>
      <url>post/7394.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>:clown_face: :clown_face: :clown_face:</p><p><strong>一、使用 typedef 定义结构体</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个名字为TreeNode的结构体类型（现在并没有定义结构体变量，并不占用内存空间）：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> Element;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">LeftChild</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">RightChild</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 为结构体起一个别名Node，这时Node就等价于struct TreeNode</span></span><br><span class="line"><span class="comment">   typedef struct TreeNode Node;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> Element;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">LeftChild</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">RightChild</span>;</span></span><br><span class="line">&#125; *PtrToTreeNode;               <span class="comment">//直接定义指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将结构体的定义和typedef语句可以连在一起写</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> Element;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">LeftChild</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">RightChild</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//融合两种写法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>    <span class="comment">//类型定义</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure><p><strong>函数形参指针变量引用总结</strong> （参考下方的相关代码定义）</p><ul><li><p>  定义 LinkList 时,LNode *L=LinkList L;</p></li><li><p>  在 main()函数中定义时指针变量要初始化指针为空，c++中初始化指针为 nullptr 最好，不然会报错。</p></li><li><p>  此时指针 L 初始化为空，L 的值为空。</p></li><li><p>  在 main()函数中定义的 L 指针如果没有先指向一个结点，那么 MethodA 的形参 L 获得的值为空，那么在 MethodA 中对 L 进行操作后，结果不改变 main()函数中的 L；</p></li><li><p>反之，在调用 MethodA 方法之前在 main()函数中给指针 L 赋值（new 一个结点让 L 指向该结点），那么就算在形参中不定义引用类型（给传入的变量取别名,如 MethodB 的形参定义），也能改变 main()函数中的指针 L；因为 main()函数中 L 指针指向的是一个地址，地址赋值给形参中的 L 后那么函数中的 L 也是对地址操作，就能改变 main 函数中的 L 指针；</p><p>  :rocket: :rocket: :rocket:</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>    <span class="comment">//类型定义</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"><span class="comment">// LinkList L = LNode *L;</span></span><br><span class="line"><span class="function">Status <span class="title">MethodA</span><span class="params">(LinkList L)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">MethodB</span><span class="params">(LinkList &amp;L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinKList L;</span><br><span class="line">    <span class="built_in">MethodA</span>(L);</span><br><span class="line">    <span class="built_in">MethodB</span>(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:rocket: :rocket: :rocket:</p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++结构体与指针</title>
      <link href="post/9c11.html"/>
      <url>post/9c11.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>结构体的使用：</strong><br>为什么使用结构体：<br>为了比表示一些复杂的数据结构，而满足用户需求的.<br>什么叫做结构体:<br>把一些基本的数据组合在一起形成一个新的复合数据类型，这个叫做结构体.<br><strong>1、如何定义一个结构体：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//（1）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//第一种定义结构的体即只定义了一个新的数据类型，并没有定义结构体变量（建议用此方法）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">float</span> score;</span><br><span class="line">   <span class="keyword">char</span> sex;</span><br><span class="line">&#125;;<span class="comment">//分好不能忘</span></span><br><span class="line"><span class="comment">//(2)第二种定义结构的方法定义结构体的同时定义结构体变量的命（不建议用此方法）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">float</span> score;</span><br><span class="line">   <span class="keyword">char</span> sex;</span><br><span class="line">&#125;stu2;</span><br><span class="line"><span class="comment">//第三种定义结构体的方式（这样也不好）这样没有结构体的名字</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">float</span> score;</span><br><span class="line">   <span class="keyword">char</span> sex;</span><br><span class="line">&#125;stu3;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span> =</span>&#123;<span class="number">80</span>,<span class="number">66.6</span>,<span class="string">&#x27;F&#x27;</span>&#125;;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、怎样使用结构体变量</strong><br><strong>赋值和初始化</strong><br>(1)初始化 定义的同时初始化附初始值<br>(2)定义完成后没有赋值只能一个一个的赋值<br><strong>如何取出结构体中的每一个成员</strong><br>(1) 结构体变量名.成员名<br>(2) 指针变量名-&gt;成员名(常用)<br>指针变量名-&gt;成员名 在计算机内部会被转化成 (*指针变量名).成员名 的方式来执行</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">float</span> score;</span><br><span class="line">   <span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span> =</span>&#123;<span class="number">80</span>,<span class="number">66.6f</span>,<span class="string">&#x27;F&#x27;</span>&#125;;<span class="comment">//初始化   定义的同时初始化附初始值</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st2</span>;</span><span class="comment">//定义完成后没有赋值只能一个一个的赋值</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> * <span class="title">pst</span> =</span> &amp;st;</span><br><span class="line">   st2.age = <span class="number">15</span>;</span><br><span class="line">   st2.score = <span class="number">3.1f</span>;<span class="comment">//C语言重66.6默认为double类型，如果希望是float类型则必须在末尾加f或者F</span></span><br><span class="line">   st2.sex = <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">   pst-&gt;age = <span class="number">99</span>;<span class="comment">//pst-&gt;age 在计算机内部会被转化成(*pst).age 也等价于st.age来执行</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;普通.运算符对结构体成员的操作结果: %d %f %c\n&quot;</span>,st2.age,st2.score,st2.sex);<span class="comment">//取值  结构体变量名.成员名</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;普通.运算符对结构体成员的操作结果: %d %f %c\n&quot;</span>,st.age,st.score,st.sex);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,pst-&gt;age);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>1、pst-&gt;age 在计算机内部会被转化成 (*pst).age<br>2、所以 pst-&gt;age 等价于 (*pst).age 也等价于 st.age<br>3、我们知道 pst-&gt;age 等价于 (*pst).age ,是因为 pst-&gt;age 是被转化成了(*pst).age 来执行的<br>4、pst-&gt;age 的含义： pst 所指向那个结构体变量中 age 这个成员<br><strong>结构体变量和结构体指针作为函数参数传递的问题</strong><br>推荐用结构体指针变量作为函数的参数来传递<br><strong>结构体重的变量的运算</strong><br>结构体变量不能相加，不能相减，也不能相互乘除，但可以相互赋值<br>结构体成员变量可以加减乘除运算</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">char</span> sex;</span><br><span class="line">   <span class="keyword">char</span> name;</span><br><span class="line">&#125;;<span class="comment">//分号不能少</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st1</span>,<span class="title">st2</span>;</span></span><br><span class="line">st1 + st2; st1*st2;st1/st2;  <span class="comment">//这些都是错的</span></span><br><span class="line">st1 = st2；<span class="comment">//这是对的</span></span><br></pre></td></tr></table></figure><p>1、要想通过函数对结构体成员变量进行操作（即修改结构体成员变量时）必须用结构体指针，形参为结构体变量的地址，否则访问不到结构体成员变量.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> age;<span class="comment">//4个字节</span></span><br><span class="line"><span class="keyword">char</span> sex;<span class="comment">//1个字节</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];<span class="comment">//100字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InpoutStudentInfo</span><span class="params">(struct Student stu)</span></span>;<span class="comment">//前置声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span>;</span></span><br><span class="line"><span class="comment">//pritnf(&quot;%d&quot;,sizeof(st));</span></span><br><span class="line"><span class="built_in">InpoutStudentInfo</span>(st);<span class="comment">//对结构体变量的输入</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %c %s\n&quot;</span>,st.age,st.sex,st.name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InpoutStudentInfo</span><span class="params">(struct Student stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   stu.age = <span class="number">10</span>;</span><br><span class="line">   <span class="built_in">strcpy</span>(stu.name,<span class="string">&quot;张三&quot;</span>);<span class="comment">//不能写成stu.name=&quot;张三&quot;;不行</span></span><br><span class="line">   stu.sex =<span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果为乱码：</strong></p><p>原因是当我们用函数操作时，其实是开辟了一段临时空间，当把结构体变量当做实参传进函数时，实际上是把结构体变量中的结构体成员在函数中复制了一份，函数运行时操作的只不过是函数临时开辟空间中存放的结构体成员变量，并没有操作到原来的结构体中的结构体成员变量。当函数运行结束后，开辟的临时空间将会销毁，在函数中对结构体成员变量的操作结果也被销毁，此时传进的结构体变量 st 并没有用到，那么他输出的是没有赋初值的结构体变量，里面是内存中的一些垃圾数据。</p><p>2、要想对结构体成员变量进行操作需实参要穿进结构体变量的首地址，形参为结构体变量的指针用于接收实参传进来的结构体变量的首地址，通过地址我们可以找到结构体成员变量然后进行修改。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> age;<span class="comment">//4个字节</span></span><br><span class="line"><span class="keyword">char</span> sex;<span class="comment">//1个字节</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];<span class="comment">//100字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InpoutStudentInfo</span><span class="params">(struct Student * pstu)</span></span>;<span class="comment">//前置声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span>;</span></span><br><span class="line"><span class="comment">//pritnf(&quot;%d&quot;,sizeof(st));</span></span><br><span class="line"><span class="built_in">InpoutStudentInfo</span>(&amp;st);<span class="comment">//对结构体变量的输入</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;分数: %d 性别: %c 姓名: %s\n&quot;</span>,st.age,st.sex,st.name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InpoutStudentInfo</span><span class="params">(struct Student * pstu)</span><span class="comment">//pstu占4个字节</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   pstu-&gt;age = <span class="number">10</span>;</span><br><span class="line">   <span class="built_in">strcpy</span>(pstu-&gt;name,<span class="string">&quot;张三&quot;</span>);<span class="comment">//不能写成stu.name=&quot;张三&quot;;不行</span></span><br><span class="line">   pstu-&gt;sex =<span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、当我们用函数仅用来输出结构体成员变量此时可以用结构体变量做实参，缺点是相当消耗空间，因为函数临时开辟的空间需要存的下传进来的结构体变量。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> age;<span class="comment">//4个字节</span></span><br><span class="line"><span class="keyword">char</span> sex;<span class="comment">//1个字节</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];<span class="comment">//100字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InpoutStudentInfo</span><span class="params">(struct Student * pstu)</span></span>;<span class="comment">//前置声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutpoutStudentInfo</span><span class="params">(struct Student stu)</span></span>;<span class="comment">//对结构体变量的输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span>;</span></span><br><span class="line"><span class="comment">//pritnf(&quot;%d&quot;,sizeof(st));</span></span><br><span class="line"><span class="built_in">InpoutStudentInfo</span>(&amp;st);<span class="comment">//对结构体变量的输入</span></span><br><span class="line"><span class="built_in">OutpoutStudentInfo</span>(st);<span class="comment">//对结构体变量的输出不建议用因为传进的参数太占空间了参数st总共占了105个字节</span></span><br><span class="line">    <span class="comment">//机器对齐填充数据组成原理中的知识导致108个字节</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InpoutStudentInfo</span><span class="params">(struct Student * pstu)</span><span class="comment">//pstu占4个字节</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   pstu-&gt;age = <span class="number">10</span>;</span><br><span class="line">   <span class="built_in">strcpy</span>(pstu-&gt;name,<span class="string">&quot;张三&quot;</span>);<span class="comment">//不能写成stu.name=&quot;张三&quot;;不行</span></span><br><span class="line">   pstu-&gt;sex =<span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutpoutStudentInfo</span><span class="params">(struct Student st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;函数临时开辟的空间大小为%d个字节\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(st));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;分数: %d 性别: %c 姓名: %s\n&quot;</span>,st.age,st.sex,st.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时发现输出结构体的函数需要开辟一个能存放结构体中所有的成员的内存空间，这样想到耗内存，而且运行慢。</p><p>4、为了减小内存开销，使运行更快我们输出结构体成员变量时实参为结构体的变量，形参为结构体变量的指针接收结构体变量的地址。优点是内存开销较小，运行快，缺点：不安全，因为在输出函数中可以对结构体的成员变量进行修改（但是我们可以用 const 来修饰形参避免对结构体的成员变量的修改）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> age;<span class="comment">//4个字节</span></span><br><span class="line"><span class="keyword">char</span> sex;<span class="comment">//1个字节</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];<span class="comment">//100字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InpoutStudentInfo</span><span class="params">(struct Student * pstu)</span></span>;<span class="comment">//前置声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutpoutStudentInfo</span><span class="params">(struct Student * stu)</span></span>;<span class="comment">//对结构体变量的输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span>;</span></span><br><span class="line"><span class="comment">//pritnf(&quot;%d&quot;,sizeof(st));</span></span><br><span class="line"><span class="built_in">InpoutStudentInfo</span>(&amp;st);<span class="comment">//对结构体变量的输入</span></span><br><span class="line"><span class="built_in">OutpoutStudentInfo</span>(&amp;st);<span class="comment">//对结构体变量的输出建议用因为参数只传进一个结构体变量的首地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InpoutStudentInfo</span><span class="params">(struct Student * pstu)</span><span class="comment">//pstu占4个字节</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   pstu-&gt;age = <span class="number">10</span>;</span><br><span class="line">   <span class="built_in">strcpy</span>(pstu-&gt;name,<span class="string">&quot;张三&quot;</span>);<span class="comment">//不能写成stu.name=&quot;张三&quot;;不行</span></span><br><span class="line">   pstu-&gt;sex =<span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutpoutStudentInfo</span><span class="params">(struct Student * st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;函数临时开辟的空间大小为%d个字节\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(&amp;st));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;函数临时开辟的空间大小为%d个字节\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(st));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;分数: %d 性别: %c 姓名: %s\n&quot;</span>,st-&gt;age,(*st).sex,st-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、指针变量存放的是变量的首地址的详解</p><p>任何类型的指针变量系统只分配四个字节，指针变量存放的是变量的首地值，例如数组的首地值，结构体变量的首地值，double 类型数据的首地值，任何类型数据的首地地址；首地值即是数据第一个字节的地址编号，每一个字节的地址编号都是 32 位的二进制，这 32 位的地址编号占四个字节，所以系统为指针变量分配四个字节来存储首地值。然后系统会根据不同类型数据的首地址用不同的寻址方式找到数据。<br><img src="/images/6.png"></p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大帅哥张茂桃</title>
      <link href="post/7589.html"/>
      <url>post/7589.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/images/1.gif" alt="大帅哥"></p><h3 id="乘风破浪懒羊羊就是我"><a href="#乘风破浪懒羊羊就是我" class="headerlink" title="乘风破浪懒羊羊就是我"></a>乘风破浪懒羊羊就是我</h3><h4 id="天不生我张茂桃，帅道万古如长夜"><a href="#天不生我张茂桃，帅道万古如长夜" class="headerlink" title="天不生我张茂桃，帅道万古如长夜"></a>天不生我张茂桃，帅道万古如长夜</h4><h4 id="天不生我张茂桃，帅道万古如长夜-1"><a href="#天不生我张茂桃，帅道万古如长夜-1" class="headerlink" title="天不生我张茂桃，帅道万古如长夜"></a>天不生我张茂桃，帅道万古如长夜</h4><h4 id="天不生我张茂桃，帅道万古如长夜-2"><a href="#天不生我张茂桃，帅道万古如长夜-2" class="headerlink" title="天不生我张茂桃，帅道万古如长夜"></a>天不生我张茂桃，帅道万古如长夜</h4><h4 id="天不生我张茂桃，帅道万古如长夜-3"><a href="#天不生我张茂桃，帅道万古如长夜-3" class="headerlink" title="天不生我张茂桃，帅道万古如长夜"></a>天不生我张茂桃，帅道万古如长夜</h4><h4 id="天不生我张茂桃，帅道万古如长夜-4"><a href="#天不生我张茂桃，帅道万古如长夜-4" class="headerlink" title="天不生我张茂桃，帅道万古如长夜"></a>天不生我张茂桃，帅道万古如长夜</h4><h4 id="天不生我张茂桃，帅道万古如长夜-5"><a href="#天不生我张茂桃，帅道万古如长夜-5" class="headerlink" title="天不生我张茂桃，帅道万古如长夜"></a>天不生我张茂桃，帅道万古如长夜</h4><h4 id="天不生我张茂桃，帅道万古如长夜-6"><a href="#天不生我张茂桃，帅道万古如长夜-6" class="headerlink" title="天不生我张茂桃，帅道万古如长夜"></a>天不生我张茂桃，帅道万古如长夜</h4><h4 id="天不生我张茂桃，帅道万古如长夜-7"><a href="#天不生我张茂桃，帅道万古如长夜-7" class="headerlink" title="天不生我张茂桃，帅道万古如长夜"></a>天不生我张茂桃，帅道万古如长夜</h4><h4 id="天不生我张茂桃，帅道万古如长夜-8"><a href="#天不生我张茂桃，帅道万古如长夜-8" class="headerlink" title="天不生我张茂桃，帅道万古如长夜"></a>天不生我张茂桃，帅道万古如长夜</h4><h4 id="天不生我张茂桃，帅道万古如长夜-9"><a href="#天不生我张茂桃，帅道万古如长夜-9" class="headerlink" title="天不生我张茂桃，帅道万古如长夜"></a>天不生我张茂桃，帅道万古如长夜</h4><h4 id="天不生我张茂桃，帅道万古如长夜-10"><a href="#天不生我张茂桃，帅道万古如长夜-10" class="headerlink" title="天不生我张茂桃，帅道万古如长夜"></a>天不生我张茂桃，帅道万古如长夜</h4><h4 id="天不生我张茂桃，帅道万古如长夜-11"><a href="#天不生我张茂桃，帅道万古如长夜-11" class="headerlink" title="天不生我张茂桃，帅道万古如长夜"></a>天不生我张茂桃，帅道万古如长夜</h4><h4 id="天不生我张茂桃，帅道万古如长夜-12"><a href="#天不生我张茂桃，帅道万古如长夜-12" class="headerlink" title="天不生我张茂桃，帅道万古如长夜"></a>天不生我张茂桃，帅道万古如长夜</h4><h4 id="天不生我张茂桃，帅道万古如长夜-13"><a href="#天不生我张茂桃，帅道万古如长夜-13" class="headerlink" title="天不生我张茂桃，帅道万古如长夜"></a>天不生我张茂桃，帅道万古如长夜</h4><h4 id="天不生我张茂桃，帅道万古如长夜-14"><a href="#天不生我张茂桃，帅道万古如长夜-14" class="headerlink" title="天不生我张茂桃，帅道万古如长夜"></a>天不生我张茂桃，帅道万古如长夜</h4><p><img src="/images/1.gif" alt="大帅哥"><br><img src="/images/5.jpg" alt="大帅哥"></p><div class="justified-gallery"><p><img src="https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg"><br><img src="https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg"><br><img src="https://i.loli.net/2019/12/25/gEy5Zc1Ai6VuO4N.jpg"><br><img src="https://i.loli.net/2019/12/25/d6QHbytlSYO4FBG.jpg"><br><img src="https://i.loli.net/2019/12/25/6nepIJ1xTgufatZ.jpg"><br><img src="https://i.loli.net/2019/12/25/E7Jvr4eIPwUNmzq.jpg"><br><img src="https://i.loli.net/2019/12/25/mh19anwBSWIkGlH.jpg"><br><img src="https://i.loli.net/2019/12/25/2tu9JC8ewpBFagv.jpg"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 二进制杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 畜生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表的实现</title>
      <link href="post/1c56.html"/>
      <url>post/1c56.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><ul><li>  删除插入结点到指定的 i 位置时要先获取第 i-1 个结点，插入不用判断第 i 个结点是否存在，删除需要判断第 i 个结点是否存在；</li><li>  头插法再循环外定义头结点的 next 域为 nullptr，尾插法在循环结束后将最后一个结点的指针域设为 nullptr；</li><li>  切记在调用函数时不要传参传错位置 :cry: :sob: :crying_cat_face: 害我找了半天啊~ :anger: :anger: :anger:</li></ul><h4 id="没注释的代码"><a href="#没注释的代码" class="headerlink" title="没注释的代码"></a>没注释的代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">DataType data;</span><br><span class="line">Node&lt;DataType&gt;* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">LinkList</span>();</span><br><span class="line"><span class="built_in">LinkList</span>(DataType a[], <span class="keyword">int</span> e);</span><br><span class="line">~<span class="built_in">LinkList</span>();</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">()</span></span>;<span class="comment">//求单链表长度</span></span><br><span class="line"><span class="function">DataType <span class="title">Get</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Locate</span><span class="params">(DataType x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> i, DataType x)</span></span>;</span><br><span class="line"><span class="function">DataType <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node&lt;DataType&gt;* first;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">LinkList&lt;DataType&gt;::<span class="built_in">LinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">first = <span class="keyword">new</span> Node;</span><br><span class="line">first-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">LinkList&lt;DataType&gt;::<span class="built_in">LinkList</span>(DataType a[], <span class="keyword">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line">first = <span class="keyword">new</span> Node&lt;DataType&gt;;</span><br><span class="line">Node&lt;DataType&gt;* p = first, * s = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line">s = <span class="keyword">new</span> Node&lt;DataType&gt;;</span><br><span class="line">s-&gt;data = a[i];</span><br><span class="line">p-&gt;next = s;</span><br><span class="line">p = s;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//first = new Node&lt;DataType&gt;;</span></span><br><span class="line"><span class="comment">//Node&lt;DataType&gt;* s = nullptr;</span></span><br><span class="line"><span class="comment">//first-&gt;next = nullptr;</span></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; e; i++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">////头插法</span></span><br><span class="line"><span class="comment">//s = new Node&lt;DataType&gt;;</span></span><br><span class="line"><span class="comment">//s-&gt;data = a[i];</span></span><br><span class="line"><span class="comment">//s-&gt;next = first-&gt;next;</span></span><br><span class="line"><span class="comment">//first-&gt;next = s;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">LinkList&lt;DataType&gt;::~<span class="built_in">LinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;DataType&gt;* s = first;</span><br><span class="line"><span class="keyword">while</span> (first != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">first = first-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> s;</span><br><span class="line">s = first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">int</span> LinkList&lt;DataType&gt;::<span class="built_in">Length</span>() &#123;</span><br><span class="line">Node&lt;DataType&gt;* p = first-&gt;next;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">DataType LinkList&lt;DataType&gt;::<span class="built_in">Get</span>(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">DataType x;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">Node&lt;DataType&gt;* p = first;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != <span class="literal">nullptr</span> &amp;&amp; count &lt; i)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">x = p-&gt;data;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">int</span> LinkList&lt;DataType&gt;::<span class="built_in">Locate</span>(DataType x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">Node&lt;DataType&gt;* p = first;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;data == x)</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">void</span> LinkList&lt;DataType&gt;::<span class="built_in">Insert</span>(<span class="keyword">int</span> i, DataType x)</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;DataType&gt;* p = first, * s = <span class="literal">nullptr</span>; <span class="comment">//工作指针p初始化</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; count &lt; i - <span class="number">1</span>)  <span class="comment">//查找第i – 1个结点</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next; <span class="comment">//工作指针p后移</span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span><span class="string">&quot;位置错误&quot;</span>; <span class="comment">//没有找到第i – 1个结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">s = <span class="keyword">new</span> Node&lt;DataType&gt;;</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">DataType LinkList&lt;DataType&gt;::<span class="built_in">Delete</span>(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">DataType x;</span><br><span class="line">Node&lt;DataType&gt;* p = first, * r = <span class="literal">nullptr</span>;   <span class="comment">//工作指针p指向头结点</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; count &lt; i - <span class="number">1</span>) <span class="comment">//查找第i-1个结点</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">nullptr</span> || p-&gt;next == <span class="literal">nullptr</span>)<span class="comment">//结点p不存在或p的后继结点不存在</span></span><br><span class="line"><span class="keyword">throw</span><span class="string">&quot;位置错误&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">r = p-&gt;next;</span><br><span class="line">x = r-&gt;data;</span><br><span class="line">p-&gt;next = r-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">bool</span> LinkList&lt;DataType&gt;::<span class="built_in">Empty</span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (first-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">void</span> LinkList&lt;DataType&gt;::<span class="built_in">PrintList</span>()</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;DataType&gt;* p = first-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;, i, x;</span><br><span class="line">LinkList&lt;<span class="keyword">int</span>&gt; L&#123; r, <span class="number">5</span> &#125;;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前线性表的数据为：&quot;</span>;</span><br><span class="line">L.<span class="built_in">PrintList</span>();                         <span class="comment">//输出当前链表1 2 3 4 5</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">L.<span class="built_in">Insert</span>(<span class="number">2</span>, <span class="number">8</span>);                         <span class="comment">//在第2个位置插入值为8的结点</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;执行插入操作后数据为：&quot;</span>;</span><br><span class="line">L.<span class="built_in">PrintList</span>();                         <span class="comment">//输出插入后链表1 8 2 3 4 5</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">char</span>* str) &#123;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前单链表的长度为：&quot;</span> &lt;&lt; L.<span class="built_in">Length</span>() &lt;&lt; endl;      <span class="comment">//输出单链表长度6</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入查找的元素值：&quot;</span>;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">i = L.<span class="built_in">Locate</span>(x);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> &lt;= i) cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;的元素位置为：&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;单链表中没有元素&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入要删除第几个元素：&quot;</span>;</span><br><span class="line">cin &gt;&gt; i;</span><br><span class="line">x = L.<span class="built_in">Delete</span>(i);                                 <span class="comment">//删除第i个元素</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;删除的元素值是&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;执行删除操作后数据为：&quot;</span>;</span><br><span class="line">L.<span class="built_in">PrintList</span>();                                 <span class="comment">//输出删除后链表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">char</span>* str) &#123;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有注释的代码"><a href="#有注释的代码" class="headerlink" title="有注释的代码"></a>有注释的代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>                  <span class="comment">//引入输入输出流</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DataType data;               <span class="comment">//数据域</span></span><br><span class="line">    Node&lt;DataType&gt;* next;       <span class="comment">//指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkList</span>();                      <span class="comment">//无参构造函数，建立只有头结点的空链表</span></span><br><span class="line">    <span class="built_in">LinkList</span>(DataType a[], <span class="keyword">int</span> n);       <span class="comment">//有参构造函数，建立有n个元素的单链表</span></span><br><span class="line">    ~<span class="built_in">LinkList</span>();                     <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">()</span></span>;                     <span class="comment">//求单链表的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Empety</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">DataType <span class="title">Get</span><span class="params">(<span class="keyword">int</span> i)</span></span>;               <span class="comment">//按位查找。查找第i个结点的元素值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Locate</span><span class="params">(DataType x)</span></span>;            <span class="comment">//按值查找。查找值为x的元素序号</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> i, DataType x)</span></span>;       <span class="comment">//插入操作，第i个位置插入值为x的结点</span></span><br><span class="line">    <span class="function">DataType <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> i)</span></span>;            <span class="comment">//删除操作，删除第i个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">()</span></span>;                  <span class="comment">//遍历操作，按序号依次输出各元素</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;DataType&gt;* first;           <span class="comment">//单链表的头指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">LinkList&lt;DataType&gt; ::<span class="built_in">LinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    first = <span class="keyword">new</span> Node&lt;DataType&gt;;              <span class="comment">//生成头结点</span></span><br><span class="line">    first-&gt;next = <span class="literal">nullptr</span>;                      <span class="comment">//头结点的指针域置空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">DataType</span>&gt;</span></span><br><span class="line">LinkList&lt;DataType&gt; :: ~<span class="built_in">LinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;DataType&gt;* q = first;       <span class="comment">//暂存被释放结点</span></span><br><span class="line">    <span class="keyword">while</span> (first != <span class="literal">nullptr</span>)        <span class="comment">//释放单链表的每一个结点的存储空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// q = first;</span></span><br><span class="line">        first = first-&gt;next;         <span class="comment">// first指向被释放结点的下一个结点</span></span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">        q = first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">int</span> LinkList&lt;DataType&gt; ::<span class="built_in">Empety</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (first-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">void</span> LinkList&lt;DataType&gt; ::<span class="built_in">PrintList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;DataType&gt;* p = first-&gt;next;                <span class="comment">//工作指针p初始化</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        p = p-&gt;next;                 <span class="comment">//工作指针p后移，注意不能写作p++</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">int</span> LinkList&lt;DataType&gt; ::<span class="built_in">Length</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;DataType&gt;* p = first-&gt;next;   <span class="comment">//工作指针p初始化为开始接点</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;                    <span class="comment">//累加器count初始化</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;              <span class="comment">//注意count的初始化和返回值之间的关系</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">DataType LinkList&lt;DataType&gt; ::<span class="built_in">Get</span>(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;DataType&gt;* p = first-&gt;next;    <span class="comment">//工作指针p初始化</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;                     <span class="comment">//累加器count初始化</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; count &lt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;                   <span class="comment">//工作指针p后移</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="keyword">throw</span> <span class="string">&quot;位置&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">int</span> LinkList&lt;DataType&gt; ::<span class="built_in">Locate</span>(DataType x)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;DataType&gt;* p = first-&gt;next;   <span class="comment">//工作指针p初始化</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;                     <span class="comment">//累加器count初始化</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == x) <span class="keyword">return</span> count;     <span class="comment">//查找成功，结束函数并返回序号</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                        <span class="comment">//退出循环表明查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">void</span> LinkList&lt;DataType&gt; ::<span class="built_in">Insert</span>(<span class="keyword">int</span> i, DataType x)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;DataType&gt;* p = first, * s = <span class="literal">nullptr</span>;        <span class="comment">//工作指针p初始化</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; count &lt; i - <span class="number">1</span>)            <span class="comment">//查找第i – 1个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;                              <span class="comment">//工作指针p后移</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="keyword">throw</span> <span class="string">&quot;位置&quot;</span>;        <span class="comment">//没有找到第i – 1个结点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        s = <span class="keyword">new</span> Node&lt;DataType&gt;; s-&gt;data = x;      <span class="comment">//申请结点s，数据域为x</span></span><br><span class="line">        s-&gt;next = p-&gt;next; p-&gt;next = s;     <span class="comment">//将结点s插入到结点p之后</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头插法构造</span></span><br><span class="line"><span class="comment">//template &lt;typename DataType&gt;</span></span><br><span class="line"><span class="comment">//LinkList&lt;DataType&gt; :: LinkList(DataType a[ ], int n)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//first = new Node&lt;DataType&gt;; first-&gt;next = nullptr;     //初始化一个空链表</span></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; n; i++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//Node&lt;DataType&gt; *s;</span></span><br><span class="line"><span class="comment">//s = new Node&lt;DataType&gt;; s-&gt;data = a[i];</span></span><br><span class="line"><span class="comment">// s-&gt;next = first-&gt;next; first-&gt;next = s;    //将结点s插入到头结点之后</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">LinkList&lt;DataType&gt; ::<span class="built_in">LinkList</span>(DataType a[], <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    first = <span class="keyword">new</span> Node&lt;DataType&gt;;                    <span class="comment">//生成头结点</span></span><br><span class="line">    Node&lt;DataType&gt;* r = first, * s = <span class="literal">nullptr</span>;           <span class="comment">//尾指针初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s = <span class="keyword">new</span> Node&lt;DataType&gt;;</span><br><span class="line">        s-&gt;data = a[i];</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;                 <span class="comment">//将结点s插入到终端结点之后</span></span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">nullptr</span>;        <span class="comment">//单链表建立完毕，将终端结点的指针域置空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template &lt;typename DataType&gt;</span></span><br><span class="line"><span class="comment">LinkList&lt;DataType&gt; ::LinkList(DataType a[], int n)//头插法</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    first = new Node&lt;DataType&gt;;                    //生成头结点</span></span><br><span class="line"><span class="comment">    Node&lt;DataType&gt;* r = first, * s = nullptr;           //尾指针初始化</span></span><br><span class="line"><span class="comment">    r-&gt;next = NULL;</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; n; i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        s = new Node&lt;DataType&gt;;</span></span><br><span class="line"><span class="comment">        s-&gt;data = a[i];</span></span><br><span class="line"><span class="comment">        s-&gt;next = r-&gt;next;</span></span><br><span class="line"><span class="comment">        r-&gt;next = s;</span></span><br><span class="line"><span class="comment">                         //将结点s插入到终端结点之后</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  //  r-&gt;next = nullptr;        //单链表建立完毕，将终端结点的指针域置空</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">DataType LinkList&lt;DataType&gt; ::<span class="built_in">Delete</span>(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    DataType x;</span><br><span class="line">    Node&lt;DataType&gt;* p = first, * q = <span class="literal">nullptr</span>;        <span class="comment">//工作指针p指向头结点</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; count &lt; i - <span class="number">1</span>)           <span class="comment">//查找第i-1个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || p-&gt;next == <span class="literal">nullptr</span>)  <span class="comment">//结点p不存在或p的后继结点不存在</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;位置错误&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        q = p-&gt;next; x = q-&gt;data;         <span class="comment">//暂存被删结点</span></span><br><span class="line">        p-&gt;next = q-&gt;next;              <span class="comment">//摘链</span></span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;, i, x;</span><br><span class="line">    LinkList&lt;<span class="keyword">int</span>&gt; L&#123; r, <span class="number">5</span> &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;当前线性表的数据为：&quot;</span>;</span><br><span class="line">    L.<span class="built_in">PrintList</span>();                         <span class="comment">//输出当前链表1 2 3 4 5</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        L.<span class="built_in">Insert</span>(<span class="number">2</span>, <span class="number">8</span>);                         <span class="comment">//在第2个位置插入值为8的结点</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;执行插入操作后数据为：&quot;</span>;</span><br><span class="line">        L.<span class="built_in">PrintList</span>();                         <span class="comment">//输出插入后链表1 8 2 3 4 5</span></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">char</span>* str) &#123;</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;当前单链表的长度为：&quot;</span> &lt;&lt; L.<span class="built_in">Length</span>() &lt;&lt; endl;      <span class="comment">//输出单链表长度6</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入查找的元素值：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    i = L.<span class="built_in">Locate</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> &lt;= i) cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;的元素位置为：&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;单链表中没有元素&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入要删除第几个元素：&quot;</span>;</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">        x = L.<span class="built_in">Delete</span>(i);                                 <span class="comment">//删除第i个元素</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;删除的元素值是&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;执行删除操作后数据为：&quot;</span>;</span><br><span class="line">        L.<span class="built_in">PrintList</span>();                                 <span class="comment">//输出删除后链表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">char</span>* str) &#123;</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTMl5 新增标签</title>
      <link href="post/90a4.html"/>
      <url>post/90a4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="web-前端：main、header、footer、nav、article、section-标签的用法"><a href="#web-前端：main、header、footer、nav、article、section-标签的用法" class="headerlink" title="web 前端：main、header、footer、nav、article、section 标签的用法"></a>web 前端：main、header、footer、nav、article、section 标签的用法</h3><hr><blockquote><p>HTML5<br>添加了诸如 main、header、footer、nav、article、section 等大量新标签，这些新标签为开发人员提供更多的选择和辅助特性。<br>默认情况下，浏览器呈现这些新标签的方式与 div 相似。然而，合理地使用它们，可以使你的标签更加的语义化。辅助技术（如：屏幕阅读器）可以通过这&gt; 些标签为用户提供更加准确的、易于理解的页面信息。</p></blockquote><h4 id="标签-main"><a href="#标签-main" class="headerlink" title="标签 main"></a><strong>标签 main</strong></h4><p>​ main 标签用于呈现网页的主体内容，且每个页面只能有一个。这意味着它只应包含与页面中心主题相关的信息，而不应包含如导航连接、网页横幅等可以在多个页面中重复出现的内容。main 标签的语义化特性可以使辅助技术快速定位到页面的主体。有些页面中有 “跳转到主要内容” 的链接，使用 main 标签可以使辅助设备自动获得这个功能。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Weapons of the Ninja<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span>//网页的主体内容<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">//main标签应该在header标签与footer标签之间。</span><br></pre></td></tr></table></figure><h4 id="标签-article"><a href="#标签-article" class="headerlink" title="标签 article"></a><strong>标签 article</strong></h4><p>​ article 是另一个具有语义化特性的 HTML5 新标签。article 是一个分段标签，用于呈现独立及完整的内容。这个标签适用于博客入口、论坛帖子或者新闻文。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Deep Thoughts with Master Camper Cat<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>The Garfield Files: Lasagna as Training Fuel?<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">The internet is littered with varying opinions on nutritional</span><br><span class="line">paradigms, from catnip paleo to hairball cleanses. But let&#x27;s turn</span><br><span class="line">our attention to an often overlooked fitness fuel, and examine the</span><br><span class="line">protein-carb-NOM trifecta that is lasagna...</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">//用于呈现独立及完整的内容</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;samuraiSwords.jpeg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Defeating your Foe: the Red Dot is Ours!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">Felines the world over have been waging war on the most persistent</span><br><span class="line">of foes. This red nemesis combines both cunning stealth and</span><br><span class="line">lightening speed. But chin up, fellow fighters, our time for victory</span><br><span class="line">may soon be near...</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;samuraiSwords.jpeg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Is Chuck Norris a Cat Person?<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">Chuck Norris is widely regarded as the premier martial artist on the</span><br><span class="line">planet, and it&#x27;s a complete coincidence anyone who disagrees with</span><br><span class="line">this fact mysteriously disappears soon after. But the real question</span><br><span class="line">is, is he a cat person?...</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="请注意-section-和-div-的区别："><a href="#请注意-section-和-div-的区别：" class="headerlink" title="请注意 section 和 div 的区别："></a><strong>请注意 section 和 div 的区别：</strong></h5><p>​ section 也是一个 HTML5 新标签，与 article 标签的语义含义略有不同。article 用于独立的、完整的内容，而 section 用于对与主题相关的内容进行分组。它们可以根据需要嵌套着使用。举个例子：如果一本书是一个 article 的话，那么每个章节就是 section。当内容组之间没有联系时，可以使用 div。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">- 内容组</span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">- 有联系的内容组</span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span>- 独立完整的内容<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="标签-header"><a href="#标签-header" class="headerlink" title="标签 header"></a><strong>标签 header</strong></h4><p>header 也是一个具有语义化的、提升页面可访问性的 HTML5 标签。它可以为父级标签呈现简介信息或者导航链接，适用于那些在多个页面顶部重复出现的内容。</p><p>与 main 类似，header 的语义化特性也可以使辅助技术快速定位到它的内容。</p><h5 id="注意：-header-用在-HTML-文档的-body-标签中。这点与包含页面标题、元信息的-head-标签不同。"><a href="#注意：-header-用在-HTML-文档的-body-标签中。这点与包含页面标题、元信息的-head-标签不同。" class="headerlink" title="注意： header 用在 HTML 文档的 body 标签中。这点与包含页面标题、元信息的 head 标签不同。"></a><strong>注意</strong>： header 用在 HTML 文档的 body 标签中。这点与包含页面标题、元信息的 head 标签不同。</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Training with Camper Cat<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">//适用于那些在多个页面顶部重复出现的内容，导航或简介信息</span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;stealth&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Stealth <span class="symbol">&amp;amp;</span> Agility Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><br><span class="line">Climb foliage quickly using a minimum spanning tree approach</span><br><span class="line"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>No training is NP-complete without parkour<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;combat&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Combat Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Dispatch multiple enemies with multithreaded tactics<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Goodbye world: 5 proven ways to knock out an opponent<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;weapons&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Weapons Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Swords: the best tool to literally divide and conquer<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Breadth-first or depth-first in multi-weapon training?<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="标签-nav"><a href="#标签-nav" class="headerlink" title="标签 nav"></a><strong>标签 nav</strong></h4><p>nav 也是一个具有语义化特性的 HTML5 标签，用于呈现页面中的主导航链接。它可以使屏幕阅读器快速识别页面中的导航信息。对于页面底部辅助性质的站点链接，不需要使用 nav，用 footer 会更好。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Training with Camper Cat<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#stealth&quot;</span>&gt;</span>Stealth <span class="symbol">&amp;amp;</span> Agility<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#combat&quot;</span>&gt;</span>Combat<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#weapons&quot;</span>&gt;</span>Weapons<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">//用于呈现页面中的主导航链接</span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;stealth&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Stealth <span class="symbol">&amp;amp;</span> Agility Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><br><span class="line">Climb foliage quickly using a minimum spanning tree approach</span><br><span class="line"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>No training is NP-complete without parkour<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;combat&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Combat Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Dispatch multiple enemies with multithreaded tactics<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Goodbye world: 5 proven ways to knock out an opponent<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;weapons&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Weapons Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Swords: the best tool to literally divide and conquer<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Breadth-first or depth-first in multi-weapon training?<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="标签-footer"><a href="#标签-footer" class="headerlink" title="标签 footer"></a><strong>标签 footer</strong></h4><p>​ 与 header 和 nav 类似，footer 也具有语义化特性，可以使辅助设备快速定位到它。它位于页面底部，用于呈现版权信息或者相关文档链接。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Training<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#stealth&quot;</span>&gt;</span>Stealth <span class="symbol">&amp;amp;</span> Agility<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#combat&quot;</span>&gt;</span>Combat<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#weapons&quot;</span>&gt;</span>Weapons<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;stealth&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Stealth <span class="symbol">&amp;amp;</span> Agility Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><br><span class="line">Climb foliage quickly using a minimum spanning tree approach</span><br><span class="line"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>No training is NP-complete without parkour<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;combat&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Combat Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Dispatch multiple enemies with multithreaded tactics<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Goodbye world: 5 proven ways to knock out an opponent<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;weapons&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Weapons Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Swords: the best tool to literally divide and conquer<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Breadth-first or depth-first in multi-weapon training?<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="symbol">&amp;copy;</span> 2016 Camper Cat<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">//用于呈现版权信息或者相关文档链接</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
