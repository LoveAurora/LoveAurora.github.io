<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>KMP算法</title>
      <link href="post/2da0528d.html"/>
      <url>post/2da0528d.html</url>
      
        <content type="html"><![CDATA[<h3 id="串的模式匹配"><a class="header-anchor" href="#串的模式匹配">¶</a>串的模式匹配</h3><p>比如主串 s=“goodgoogle”,子串 t=“google”。现在我们要找到子串 t 在主串 s 中的位置。</p><h4 id="第一种-就是暴力求解法"><a class="header-anchor" href="#第一种-就是暴力求解法">¶</a>第一种 就是暴力求解法</h4><p>这种方法也叫 <span class='p red small'>朴素的模式匹配:</span></p><p>简单来说就是：从主串 s 和子串 t 的第一个字符开始，将两字符串的字符一一比对，如果出现某个字符不匹配，主串回溯到第二个字符，子串回溯到第一个字符再进行一一比对。如果出现某个字符不匹配，主串回溯到第三个字符，子串回溯到第一个字符再进行一一比对…一直到子串字符全部匹配成功。</p><details yellow><summary> 查看具体代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(sstring s,sstring t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">while</span> (i &lt; t.length &amp;&amp; t.length) &#123;</span><br><span class="line"><span class="keyword">if</span> (s.data[i] == t.data[j]) &#123;</span><br><span class="line">i++, j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">i = i - j + <span class="number">2</span>;</span><br><span class="line">j = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt; t.length)</span><br><span class="line"><span class="keyword">return</span> i - t.length;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details><h4 id="第二种-KMP-算法"><a class="header-anchor" href="#第二种-KMP-算法">¶</a>第二种 KMP 算法</h4><p>事实上，<strong>每一个字符前的字符串都有最长相等前后缀</strong>，而且<strong>最长相等前后缀的长度是我们移位的关键</strong>，所以我们单独用一个 next 数组存储子串的最长相等前后缀的长度。<strong>而且 next 数组的数值只与子串本身有关。</strong></p><h5 id="next-数组手算方法："><a class="header-anchor" href="#next-数组手算方法：">¶</a>next 数组手算方法：</h5><p>当第 j 个字符匹配失败，由前 1~j-1 个字符组成的串记为 S，则 next[j]=s 的最长相等前后缀长度+1，特别的，next[1]=0。所以 next[i]=j,含义是：下标为 i 的字符前的字符串最长相等前后缀的长度为 j。</p><blockquote><ol><li>next[i]的值表示下标为 i 的字符前的字符串最长相等前后缀的长度。</li><li>表示该处字符不匹配时应该回溯到的字符的下标。</li></ol></blockquote><details yellow><summary> 查看具体代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(sstring t, <span class="keyword">int</span> next[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">i = <span class="number">1</span>, j = <span class="number">0</span>; <span class="comment">//舍去一个存储空间，让数组中第i个位置的元素等于该字符在字符串中的位置,方便理解</span></span><br><span class="line">next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//第一个字符前无字符，赋值为 0</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; t.length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span> || t.data[i] == t.data[j])<span class="comment">//j==0是当字符不匹配是，用来对i指针进行移位的。</span></span><br><span class="line">        &#123;</span><br><span class="line">i++, j++; <span class="comment">//一般来说 next[0] next[1] 的值都为1</span></span><br><span class="line">next[i] = j;</span><br><span class="line"><span class="comment">// 对应字符匹配情况下，s与t指向同步后移</span></span><br><span class="line"><span class="comment">// next[i] = j;表示在第i前面的子串的最大匹配值。当data[i]与data[j]的字符不匹配时，j会回溯到上一个能匹配的位置，然后再比较</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">j = next[j];</span><br><span class="line"><span class="comment">//next[j]的值代表的是下标为k的字符前面的字符串最长相等前后缀的长度</span></span><br><span class="line"><span class="comment">//也表示该处字符不匹配时应该回溯到的字符的下标</span></span><br><span class="line"><span class="comment">//这个值给j后又进行while循环判断，此时t.data[j]即指最长相等前缀后一个字符</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="KMP-算法的改进"><a class="header-anchor" href="#KMP-算法的改进">¶</a>KMP 算法的改进</h3><p>为什么 KMP 还需要改进？<br>如下例子:<br>主串 s=“aaaaabaaaaac”,子串 t=“aaaaac”<br>这个例子中当‘b’与‘c’不匹配时应该‘b’与’c’前一位的‘a’比,这显然是不匹配的。'c’前的’a’回溯后的字符依然是‘a’。<br><strong>我们知道没有必要再将‘b’与‘a’比对了</strong>，因为回溯后的字符和原字符是相同的，原字符不匹配，回溯后的字符自然不可能匹配。但是 KMP 算法中依然会将‘b’与回溯到的‘a’进行比对。这就是我们可以改进的地方了。我们改进后的 next 数组命名为：nextval 数组。KMP 算法的改进可以简述为： **如果 a 位字符与它 next 值指向的 b 位字符相等，则该 a 位的 nextval 就指向 b 位的 nextval 值，如果不等，则该 a 位的 nextval 值就是它自己 a 位的 next 值。**如字符串&quot;ababaaab&quot;的 next 数组以及 nextval 数组分别为：</p><table><thead><tr><th style="text-align:center">下标</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th></tr></thead><tbody><tr><td style="text-align:center">子串</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">next</td><td style="text-align:center">-1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">nextval</td><td style="text-align:center">-1</td><td style="text-align:center">0</td><td style="text-align:center">-1</td><td style="text-align:center">0</td><td style="text-align:center">-1</td><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><details yellow><summary> 查看具体代码 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNextval</span><span class="params">(SqString t,<span class="keyword">int</span> nextval[])</span></span></span><br><span class="line"><span class="function"><span class="comment">//由模式串t求出nextval值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>,k=<span class="number">-1</span>;</span><br><span class="line">nextval[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">while</span> (j&lt;t.length)</span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">if</span> (k==<span class="number">-1</span> || t.data[j]==t.data[k])</span><br><span class="line">&#123;</span><br><span class="line">j++;k++;</span><br><span class="line"><span class="keyword">if</span> (t.data[j]!=t.data[k])</span><br><span class="line">                        <span class="comment">//这里的t.data[k]是t.data[j]处字符不匹配而会回溯到的字符</span></span><br><span class="line">                        <span class="comment">//为什么？因为没有这处if判断的话，此处代码是next[j]=k;</span></span><br><span class="line">                        <span class="comment">//next[j]不就是t.data[j]不匹配时应该回溯到的字符位置嘛</span></span><br><span class="line">                </span><br><span class="line">nextval[j]=k;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">nextval[j]=nextval[k];</span><br><span class="line">            </span><br><span class="line">                <span class="comment">//此时nextval[j]的值就是就是t.data[j]不匹配时应该回溯到的字符的nextval值</span></span><br><span class="line">                <span class="comment">//即字符不匹配时回溯两层后对应的字符下标</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>  </span><br><span class="line">            k=nextval[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMPIndex1</span><span class="params">(SqString s,SqString t)</span></span></span><br><span class="line"><span class="function"><span class="comment">//修正的KMP算法</span></span></span><br><span class="line"><span class="function"><span class="comment">//只是next换成了nextval</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> nextval[MaxSize],i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">GetNextval</span>(t,nextval);</span><br><span class="line"><span class="keyword">while</span> (i&lt;s.length &amp;&amp; j&lt;t.length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j==<span class="number">-1</span> || s.data[i]==t.data[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> j=nextval[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j&gt;=t.length)</span><br><span class="line"><span class="keyword">return</span>(i-t.length);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in"><span class="keyword">return</span></span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details><div class='poem'><div class='poem-title'>水调歌头</div><div class='poem-author'>苏轼</div><p>丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。<br>明月几时有？把酒问青天。<br>不知天上宫阙，今夕是何年？<br>我欲乘风归去，又恐琼楼玉宇，高处不胜寒。<br>起舞弄清影，何似在人间？</p><p>转朱阁，低绮户，照无眠。<br>不应有恨，何事长向别时圆？<br>人有悲欢离合，月有阴晴圆缺，此事古难全。<br>但愿人长久，千里共婵娟。</p></div>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列的两种实现方式</title>
      <link href="post/c2ed.html"/>
      <url>post/c2ed.html</url>
      
        <content type="html"><![CDATA[<h4 id="队列的链式实现-🐨"><a class="header-anchor" href="#队列的链式实现-🐨">¶</a>队列的链式实现 🐨</h4><ul><li>🌻 链队的初始化实现采用的是不带头结点的方法，前边链式实现顺序表和栈时用的带头结点的方法，这次用不带头结点的方法，一是多掌握，二是考试考到可以做快。☁️<ul><li>初始化队列时由于不带头指针，在第一个位置加了一个 if()判断，区别于后边结点的插法。🐑</li><li>由于头指针和尾指针都是指向相同类型的结构体，把两个指针定义到同一个结构体中，否则，还要在 main()函数中定义头指针和尾指针，然后传入函数中操作，形参也要多定义一个。</li><li>由于没定义头结点，只能定义指针，在形参中一定注意使用引用</li></ul></li></ul><ul><li>➕ 自我反省<ul><li>⚠️ 自己做的时候在定义出队函数时没注意，然后运行时发现连续出队两次就报错,调试半天才发现在形参中未定义引用类型。再复习一次关于结点与指针是否使用引用 ⚠️</li><li>因为不定义引用类型，如果传进去的是个结点，系统在内存中开辟一片区域，里面存有和传入节点一样的 data，一样的 next，因为形参结点带有传入结点的 next 指针域，对复制的结点操作一样能改变原结点后边的结点。如果是指针的话，传入的是指针指向的地址，指针操作了结点后，不改变原来 main()函数的指针指向的地址，如果没对结点进行增删，再次调用函数，不会对原队列有影响，否则，传入的指针的会找不到指向的位置。定义了引用类型，上边的错误就不会存在。</li><li>详情参考 <code> bool DeQueue() ,EleType GetTop(),void Print(),string IsEmpty()</code>这四个函数形参的定义。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EleType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">EleType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;*LinkNode;</span><br><span class="line"><span class="comment">//将头指针尾指针放入一个结构体中</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">LinkNode front, rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">( LinkQueue&amp; r, EleType x)</span> </span>&#123;</span><br><span class="line">LinkNode q = r.rear, s;</span><br><span class="line">s = <span class="keyword">new</span> Node;</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">s-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">q-&gt;next = s;</span><br><span class="line">q = q-&gt;next;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;r, EleType&amp; x)</span> </span>&#123;</span><br><span class="line">LinkNode q;</span><br><span class="line"><span class="keyword">if</span> (r.front == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">x = <span class="number">999999999</span>;<span class="comment">//如果x打印为999999999表示链队列为空。</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">x = r.front-&gt;data;</span><br><span class="line">q = r.front;</span><br><span class="line">r.front = r.front-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> q;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="function">LinkNode <span class="title">InitQueue</span><span class="params">(LinkNode&amp; L, LinkQueue&amp; r, EleType a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*L = new Node;*/</span></span><br><span class="line">L = <span class="literal">nullptr</span>;</span><br><span class="line">LinkNode s;</span><br><span class="line">r.front = L;</span><br><span class="line">r.rear = L;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">s = <span class="keyword">new</span> Node;</span><br><span class="line">s-&gt;data = a[i];</span><br><span class="line">s-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">r.rear = s;</span><br><span class="line">s-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">r.front = r.rear;</span><br><span class="line">L = r.rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">r.rear-&gt;next = s;</span><br><span class="line">r.rear = s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取队头元素</span></span><br><span class="line"><span class="function">EleType <span class="title">GetTop</span><span class="params">(LinkQueue r)</span> </span>&#123;</span><br><span class="line">EleType x;</span><br><span class="line"><span class="keyword">if</span> (r.front == <span class="literal">nullptr</span>) <span class="comment">//记得加条件判断当前栈是否为空，否则当队列为空时，出队会出错。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">x = r.front-&gt;data;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function">string <span class="title">IsEmpty</span><span class="params">( LinkQueue r)</span> </span>&#123;</span><br><span class="line">string text;</span><br><span class="line"><span class="keyword">if</span> (r.front == <span class="literal">nullptr</span>)</span><br><span class="line">text = <span class="string">&quot;队列为空&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">text = <span class="string">&quot;队列不为空&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">( LinkQueue r)</span> </span>&#123;</span><br><span class="line">LinkNode s=r.front;</span><br><span class="line"><span class="keyword">while</span> (s!=<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; s-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">s = s-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LinkNode L;</span><br><span class="line">LinkQueue r;</span><br><span class="line">EleType x;</span><br><span class="line"><span class="comment">/*EleType a[] = &#123; 1,2,3,999,888,555 &#125;;*/</span></span><br><span class="line">EleType a[] = &#123; <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">InitQueue</span>(L, r, a, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">Print</span>(r);</span><br><span class="line">cout &lt;&lt; <span class="built_in">IsEmpty</span>( r) &lt;&lt; endl;</span><br><span class="line"><span class="built_in">GetTop</span>(r);</span><br><span class="line"><span class="built_in">EnQueue</span>( r, <span class="number">55</span>);</span><br><span class="line"><span class="built_in">Print</span>(r);</span><br><span class="line"><span class="built_in">DeQueue</span>( r, x);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"><span class="built_in">DeQueue</span>(r, x);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"><span class="built_in">DeQueue</span>(r, x);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="顺序队列的实现-⛅️"><a class="header-anchor" href="#顺序队列的实现-⛅️">¶</a>顺序队列的实现 ⛅️</h4><ul><li><p>由于顺序队列采用一般的数组的话，当出队入队多进行几次，就会出现上溢。🐐</p></li><li><p>采用循环数组可以提高空间利用率。🤡</p></li><li><p>核心是操作数组下标时，要采用取余的方式。👑</p></li><li><p>头指针指向第一个元素的位置，尾指针指向最后一个元素的位置，有三种判断队列是否为空，满的方式。🎲</p><ul><li>牺牲一个存储单元来判断队列是否为满，队满 L.rear + 1) % MaxSize == L.front % MaxSize；队空 L.front % MaxSize == L.rear % MaxSize；</li><li>增加一个变量存储当前的队列长度，就不用牺牲存储单元，length=0，空；length=MaxSize 满。</li><li>增加一个 flag 变量，如果出队就改变 flag = -1，入队 flag = 0。在判断 front == rear 时，flag = -1 队空，flag = 0 队满。</li></ul></li><li><p>头指针尾指针的位置并不是固定放在某个位置，看具体的题，具体判断。💮</p></li></ul><ul><li>自我反省关于多次调用 Print()函数出现错误 😢<ul><li>⚠️ 由于在 Print() 定义了引用变量，导致多次打印数组错误，对链式的数据结构，采用定义引用形参打印时没影响，静态数据结构用引用就会影响！⚠️</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EleType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">EleType data[MaxSize];</span><br><span class="line"><span class="keyword">int</span> front;</span><br><span class="line"><span class="keyword">int</span> rear;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line">&#125;SeqQueue;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SeqQueue&amp; L)</span> </span>&#123;</span><br><span class="line"><span class="comment">//顺序循环队列初始化将头指针和尾指针同时指向数组高端</span></span><br><span class="line"><span class="comment">//头指针指向第一个元素前的位置，尾指针指向最后一个元素的位置</span></span><br><span class="line">L.front = <span class="number">0</span>; <span class="comment">// front 指向队头元素</span></span><br><span class="line">L.rear = <span class="number">0</span>;  <span class="comment">// rear 指向队尾元素</span></span><br><span class="line">L.length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">while</span> (x != <span class="number">999</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (L.length &lt;= MaxSize)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">L.data[L.rear % MaxSize] = x;</span><br><span class="line">L.rear = (L.rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">&#125;</span><br><span class="line">L.length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(SeqQueue&amp; L)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L.rear == L.front - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryQueue</span><span class="params">(SeqQueue&amp; L)</span> </span>&#123;</span><br><span class="line">L.front = L.rear = MaxSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SeqQueue&amp; L, <span class="keyword">int</span>  x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((L.rear + <span class="number">1</span>) % MaxSize == L.front % MaxSize)<span class="comment">//牺牲一个存储单元来判断队列是否为满，队满，L.rear+1 = L.front；</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//if (L.length == MaxSize)//增加一个变量存储当前的队列长度，就不用牺牲存储单元</span></span><br><span class="line"><span class="comment">//return false;</span></span><br><span class="line"><span class="comment">//if (L.front % MaxSize == L.rear%MaxSize &amp;&amp; L.falg == -1)//增加一个变量存储最后一次的操作是出队还是入队，就不用牺牲存储单元</span></span><br><span class="line"><span class="comment">//return false;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">L.data[L.rear] = x;</span><br><span class="line">L.rear = (L.rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">L.length++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SeqQueue&amp; L, <span class="keyword">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L.front % MaxSize == L.rear % MaxSize)<span class="comment">//牺牲一个存储单元来判断队列是否为满，队空，和初始化一样，L.frontt = L.rear;</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//if (L.length == 0)//增加一个变量存储当前的队列长度，就不用牺牲存储单元</span></span><br><span class="line"><span class="comment">//return false;</span></span><br><span class="line"><span class="comment">//if (L.front % MaxSize == L.rear%MaxSize &amp;&amp; L.falg == -1)//增加一个变量存储最后一次的操作是出队还是入队，就不用牺牲存储单元</span></span><br><span class="line"><span class="comment">//return false;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">x = L.data[L.front];</span><br><span class="line">L.front = (L.front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">&#125;</span><br><span class="line">L.length--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">EleType <span class="title">GetHead</span><span class="params">(SeqQueue&amp; L, EleType&amp; x)</span> </span>&#123;</span><br><span class="line">x = L.data[L.front];</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(SeqQueue L)</span> </span>&#123;</span><br><span class="line">EleType num;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">num = (L.front) % MaxSize;</span><br><span class="line">cout &lt;&lt; L.data[num] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">L.front = (L.front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SeqQueue L = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">InitQueue</span>(L);</span><br><span class="line"><span class="built_in">Print</span>(L);</span><br><span class="line"><span class="built_in">EnQueue</span>(L, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">Print</span>(L);</span><br><span class="line"><span class="built_in">DeQueue</span>(L, x);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;出队元素：&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求极限</title>
      <link href="post/bcb3582b.html"/>
      <url>post/bcb3582b.html</url>
      
        <content type="html"><![CDATA[<h4 id="极限的定义"><a class="header-anchor" href="#极限的定义">¶</a>极限的定义</h4><ol><li><p>如果商的极限等于分子和分母求极限后取商 需要分子和分母极限同时存在 否则极限的四则运算不成立 分母极限是无穷 所以不成立。附图🔗</p><img src='../../images/math/ultra.jpg' width="700px" style="margin:0 auto;"></li></ol>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序表的动态扩容</title>
      <link href="post/5e54.html"/>
      <url>post/5e54.html</url>
      
        <content type="html"><![CDATA[<h4 id="顺序表的动态扩容"><a class="header-anchor" href="#顺序表的动态扩容">¶</a>顺序表的动态扩容</h4><ul><li><p>插入操作判断位置是否合法(位置取值范围在 1~length+1），另外还要判断当前表是否为满(L.length &gt;= L.MaxSize)。 💃</p><ul><li><p>把每个元素往后移动一位，直到输入的插入的位置 ​ 💪💪💪。</p></li><li><p>第 n 个位置对应的值在数组中的值为 data[n-1]。</p></li><li><p>代码操作如下：</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertList</span><span class="params">(SeqList L, <span class="keyword">int</span> i, <span class="keyword">int</span> e)</span> <span class="comment">//插入操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (L.length &gt;= L.MaxSize)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = L.length; j &gt;= i; j--)</span><br><span class="line">  &#123;</span><br><span class="line">    L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  L.data[i - <span class="number">1</span>] = e;</span><br><span class="line">  L.length++;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除操作判断位置是否合法（位置取值范围 1~length），另外还要判断当前表是否为空 L.length &lt;= 0。🐓 ​</p><ul><li><p>取出删除位置的元素，然后把每个元素往前移动一位，直到输入的删除的位置。🐶</p></li><li><p>第 n 个位置对应的值在数组中的值为 data[n-1]。</p></li><li><p>代码操作如下：</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteList</span><span class="params">(SeqList L, <span class="keyword">int</span> i, <span class="keyword">int</span> &amp;e)</span> <span class="comment">//删除操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (L.length &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  e = L.data[i - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; L.length; j--)</span><br><span class="line">  &#123;</span><br><span class="line">    L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  L.length--;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>🍰 ⏯</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> *data;</span><br><span class="line"><span class="keyword">int</span> MaxSize;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line">&#125; SeqList;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SeqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">L.data = <span class="keyword">new</span> <span class="keyword">int</span>[InitSize];</span><br><span class="line">L.MaxSize = InitSize;</span><br><span class="line">L.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IncreaseList</span><span class="params">(SeqList L, <span class="keyword">int</span> len)</span> <span class="comment">//动态扩容</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = L.data;</span><br><span class="line">L.data = <span class="keyword">new</span> <span class="keyword">int</span>[(L.MaxSize + len)];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">  L.data[i] = p[i];</span><br><span class="line">&#125;</span><br><span class="line">L.MaxSize = L.MaxSize + len;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertList</span><span class="params">(SeqList L, <span class="keyword">int</span> i, <span class="keyword">int</span> e)</span> <span class="comment">//插入操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (L.length &gt;= L.MaxSize)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = L.length; j &gt;= i; j--)</span><br><span class="line">&#123;</span><br><span class="line">  L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">L.data[i - <span class="number">1</span>] = e;</span><br><span class="line">L.length++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//length=位置</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteList</span><span class="params">(SeqList L, <span class="keyword">int</span> i, <span class="keyword">int</span> &amp;e)</span> <span class="comment">//删除操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (L.length &lt;= <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">e = L.data[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; L.length; j--)</span><br><span class="line">&#123;</span><br><span class="line">  L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">L.length--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLocate</span><span class="params">(SeqList L, <span class="keyword">int</span> e)</span> <span class="comment">//按值查找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">  <span class="keyword">if</span> (L.data[i] == e)</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElement</span><span class="params">(SeqList L, <span class="keyword">int</span> i)</span> <span class="comment">//按位查找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Put</span><span class="params">(SeqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, L.data[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SeqList L;</span><br><span class="line"><span class="built_in">InitList</span>(L);</span><br><span class="line"><span class="built_in">InsertList</span>(L, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">InsertList</span>(L, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">InsertList</span>(L, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">Put</span>(L);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈的两种实现方式</title>
      <link href="post/e2a9.html"/>
      <url>post/e2a9.html</url>
      
        <content type="html"><![CDATA[<h4 id="🙌-顺序栈-🙌"><a class="header-anchor" href="#🙌-顺序栈-🙌">¶</a>🙌 顺序栈 🙌</h4><ul><li>Push()函数判满 -&gt; 顺序栈用的是数组，下标从 0 开始，top = MaxSize-1 ; 栈满 ; 🚀</li><li>Pop()函数判空 -&gt; 顺序栈用的是数组，下标从 0 开始，top = -1;栈空; 🚀</li><li>Print()函数遍历打印完全 -&gt; top 相当于数组的下标，i&lt;S.top 才能把栈遍历完全。🚀</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EleType;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">EleType data[MaxSize];</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line">&#125;SeqStack;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SeqStack&amp; S)</span> </span>&#123;</span><br><span class="line">S.top = <span class="number">-1</span>;</span><br><span class="line">S.length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">while</span> (x != <span class="number">999</span>&amp;&amp; S.length &lt; MaxSize) &#123; <span class="comment">//用length&lt;MaxSize 确保构造的栈不会溢出</span></span><br><span class="line">S.data[++S.top] = x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">S.length++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SeqStack&amp; S, EleType x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == MaxSize - <span class="number">1</span>)<span class="comment">//顺序栈用的是数组，下标从0开始，top = MaxSize-1;栈满;</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">S.data[++S.top] = x;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SeqStack&amp; S, EleType&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == <span class="number">-1</span>)<span class="comment">//顺序栈用的是数组，下标从0开始，top = -1;栈空;</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x = S.data[S.top--];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(SeqStack&amp; S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= S.top; i++)<span class="comment">//top相当于数组的下标，i&lt;S.top 才能把栈遍历完全。</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; S.data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">SeqStack S = &#123;&#125;;</span><br><span class="line"><span class="built_in">InitStack</span>(S);</span><br><span class="line"><span class="built_in">Push</span>(S, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">Print</span>(S);</span><br><span class="line"><span class="built_in">Pop</span>(S, x);</span><br><span class="line"><span class="built_in">Print</span>(S);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="🐘-栈的链式存储-🐘"><a class="header-anchor" href="#🐘-栈的链式存储-🐘">¶</a>🐘 栈的链式存储 🐘</h3><ul><li>下边代码用的是带头结点的写法，题中如果说明了要用未带头结点的写法，要注意。 😢</li><li>链栈初始化和链表初始化一样。😆</li><li>入栈出栈在头结点后操作。 👽</li></ul><h4 id="自我反省"><a class="header-anchor" href="#自我反省">¶</a>自我反省</h4><ul><li>出栈要判断栈是否为空，取栈顶元素也要判断栈顶是否为空(⚠️ 在第一次写时就没有在 GetTop()函数中判断 ⚠️ )</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EleType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">EleType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Stack, * LinkStack;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(LinkStack&amp; L, EleType x)</span> </span>&#123;</span><br><span class="line">LinkStack r = L-&gt;next, s;</span><br><span class="line">s = <span class="keyword">new</span> Node;</span><br><span class="line">s-&gt;next = r;</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">L-&gt;next = s;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(LinkStack&amp; L, EleType&amp; x)</span> </span>&#123;</span><br><span class="line">LinkStack r = L-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (r == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">x = <span class="number">999999999</span>; <span class="comment">//如果x打印为999999999表示链栈为空。</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">x = r-&gt;data;</span><br><span class="line">L-&gt;next = r-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> r;</span><br><span class="line">r = L-&gt;next;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Stack* <span class="title">InitStack</span><span class="params">(LinkStack&amp; L)</span> </span>&#123;</span><br><span class="line">L = <span class="keyword">new</span> Node;</span><br><span class="line">L-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">LinkStack s, r = L;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">while</span> (x != <span class="number">999</span>) &#123;</span><br><span class="line">s = <span class="keyword">new</span> Node;</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">s-&gt;next = r-&gt;next;</span><br><span class="line">r-&gt;next = s;</span><br><span class="line">r = r-&gt;next;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">EleType <span class="title">GetTop</span><span class="params">(LinkStack&amp; L)</span> </span>&#123;</span><br><span class="line">EleType x;</span><br><span class="line">LinkStack r = L-&gt;next;</span><br><span class="line">  <span class="keyword">if</span> (r == <span class="literal">nullptr</span>) <span class="comment">//记得加条件判断当前栈是否为空，否则当栈为空时，出栈会出错。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">x = r-&gt;data;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LinkStack L;</span><br><span class="line">EleType x;</span><br><span class="line"><span class="built_in">InitStack</span>(L);</span><br><span class="line"><span class="built_in">GetTop</span>(L);</span><br><span class="line"><span class="built_in">Push</span>(L, <span class="number">55</span>);</span><br><span class="line"><span class="built_in">Pop</span>(L, x);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形参指针变量和引用</title>
      <link href="post/7394.html"/>
      <url>post/7394.html</url>
      
        <content type="html"><![CDATA[<p>🤡 🤡 🤡</p><p><strong>一、使用 typedef 定义结构体</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个名字为TreeNode的结构体类型（现在并没有定义结构体变量，并不占用内存空间）：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> Element;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">LeftChild</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">RightChild</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 为结构体起一个别名Node，这时Node就等价于struct TreeNode</span></span><br><span class="line"><span class="comment">   typedef struct TreeNode Node;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> Element;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">LeftChild</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">RightChild</span>;</span></span><br><span class="line">&#125; *PtrToTreeNode;               <span class="comment">//直接定义指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将结构体的定义和typedef语句可以连在一起写</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> Element;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">LeftChild</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">RightChild</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//融合两种写法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>    <span class="comment">//类型定义</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure><p><strong>函数形参指针变量引用总结</strong> （参考下方的相关代码定义）</p><ul><li><p>定义 LinkList 时,LNode *L=LinkList L;</p></li><li><p>在 main()函数中定义时指针变量要初始化指针为空，c++中初始化指针为 nullptr 最好，不然会报错。</p></li><li><p>此时指针 L 初始化为空，L 的值为空。</p></li><li><p>在 main()函数中定义的 L 指针如果没有先指向一个结点，那么 MethodA 的形参 L 获得的值为空，那么在 MethodA 中对 L 进行操作后，结果不改变 main()函数中的 L；</p></li><li><p>反之，在调用 MethodA 方法之前在 main()函数中给指针 L 赋值（new 一个结点让 L 指向该结点），那么就算在形参中不定义引用类型（给传入的变量取别名,如 MethodB 的形参定义），也能改变 main()函数中的指针 L；因为 main()函数中 L 指针指向的是一个地址，地址赋值给形参中的 L 后那么函数中的 L 也是对地址操作，就能改变 main 函数中的 L 指针；</p><p>🚀 🚀 🚀</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>    <span class="comment">//类型定义</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"><span class="comment">// LinkList L = LNode *L;</span></span><br><span class="line"><span class="function">Status <span class="title">MethodA</span><span class="params">(LinkList L)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">MethodB</span><span class="params">(LinkList &amp;L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinKList L;</span><br><span class="line">    <span class="built_in">MethodA</span>(L);</span><br><span class="line">    <span class="built_in">MethodB</span>(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🚀 🚀 🚀</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++结构体与指针</title>
      <link href="post/9c11.html"/>
      <url>post/9c11.html</url>
      
        <content type="html"><![CDATA[<p><strong>结构体的使用：</strong><br>为什么使用结构体：<br>为了比表示一些复杂的数据结构，而满足用户需求的.<br>什么叫做结构体:<br>把一些基本的数据组合在一起形成一个新的复合数据类型，这个叫做结构体.<br><strong>1、如何定义一个结构体：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//（1）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//第一种定义结构的体即只定义了一个新的数据类型，并没有定义结构体变量（建议用此方法）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">float</span> score;</span><br><span class="line">   <span class="keyword">char</span> sex;</span><br><span class="line">&#125;;<span class="comment">//分好不能忘</span></span><br><span class="line"><span class="comment">//(2)第二种定义结构的方法定义结构体的同时定义结构体变量的命（不建议用此方法）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">float</span> score;</span><br><span class="line">   <span class="keyword">char</span> sex;</span><br><span class="line">&#125;stu2;</span><br><span class="line"><span class="comment">//第三种定义结构体的方式（这样也不好）这样没有结构体的名字</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">float</span> score;</span><br><span class="line">   <span class="keyword">char</span> sex;</span><br><span class="line">&#125;stu3;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span> =</span>&#123;<span class="number">80</span>,<span class="number">66.6</span>,<span class="string">&#x27;F&#x27;</span>&#125;;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、怎样使用结构体变量</strong><br><strong>赋值和初始化</strong><br>(1)初始化 定义的同时初始化附初始值<br>(2)定义完成后没有赋值只能一个一个的赋值<br><strong>如何取出结构体中的每一个成员</strong><br>(1) 结构体变量名.成员名<br>(2) 指针变量名-&gt;成员名(常用)<br>指针变量名-&gt;成员名 在计算机内部会被转化成 (*指针变量名).成员名 的方式来执行</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">float</span> score;</span><br><span class="line">   <span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span> =</span>&#123;<span class="number">80</span>,<span class="number">66.6f</span>,<span class="string">&#x27;F&#x27;</span>&#125;;<span class="comment">//初始化   定义的同时初始化附初始值</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st2</span>;</span><span class="comment">//定义完成后没有赋值只能一个一个的赋值</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> * <span class="title">pst</span> =</span> &amp;st;</span><br><span class="line">   st2.age = <span class="number">15</span>;</span><br><span class="line">   st2.score = <span class="number">3.1f</span>;<span class="comment">//C语言重66.6默认为double类型，如果希望是float类型则必须在末尾加f或者F</span></span><br><span class="line">   st2.sex = <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">   pst-&gt;age = <span class="number">99</span>;<span class="comment">//pst-&gt;age 在计算机内部会被转化成(*pst).age 也等价于st.age来执行</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;普通.运算符对结构体成员的操作结果: %d %f %c\n&quot;</span>,st2.age,st2.score,st2.sex);<span class="comment">//取值  结构体变量名.成员名</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;普通.运算符对结构体成员的操作结果: %d %f %c\n&quot;</span>,st.age,st.score,st.sex);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,pst-&gt;age);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>1、pst-&gt;age 在计算机内部会被转化成 (*pst).age<br>2、所以 pst-&gt;age 等价于 (*pst).age 也等价于 st.age<br>3、我们知道 pst-&gt;age 等价于 (*pst).age ,是因为 pst-&gt;age 是被转化成了(*pst).age 来执行的<br>4、pst-&gt;age 的含义： pst 所指向那个结构体变量中 age 这个成员<br><strong>结构体变量和结构体指针作为函数参数传递的问题</strong><br>推荐用结构体指针变量作为函数的参数来传递<br><strong>结构体重的变量的运算</strong><br>结构体变量不能相加，不能相减，也不能相互乘除，但可以相互赋值<br>结构体成员变量可以加减乘除运算</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">char</span> sex;</span><br><span class="line">   <span class="keyword">char</span> name;</span><br><span class="line">&#125;;<span class="comment">//分号不能少</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st1</span>,<span class="title">st2</span>;</span></span><br><span class="line">st1 + st2; st1*st2;st1/st2;  <span class="comment">//这些都是错的</span></span><br><span class="line">st1 = st2；<span class="comment">//这是对的</span></span><br></pre></td></tr></table></figure><p>1、要想通过函数对结构体成员变量进行操作（即修改结构体成员变量时）必须用结构体指针，形参为结构体变量的地址，否则访问不到结构体成员变量.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> age;<span class="comment">//4个字节</span></span><br><span class="line"><span class="keyword">char</span> sex;<span class="comment">//1个字节</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];<span class="comment">//100字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InpoutStudentInfo</span><span class="params">(struct Student stu)</span></span>;<span class="comment">//前置声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span>;</span></span><br><span class="line"><span class="comment">//pritnf(&quot;%d&quot;,sizeof(st));</span></span><br><span class="line"><span class="built_in">InpoutStudentInfo</span>(st);<span class="comment">//对结构体变量的输入</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %c %s\n&quot;</span>,st.age,st.sex,st.name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InpoutStudentInfo</span><span class="params">(struct Student stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   stu.age = <span class="number">10</span>;</span><br><span class="line">   <span class="built_in">strcpy</span>(stu.name,<span class="string">&quot;张三&quot;</span>);<span class="comment">//不能写成stu.name=&quot;张三&quot;;不行</span></span><br><span class="line">   stu.sex =<span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果为乱码：</strong></p><p>原因是当我们用函数操作时，其实是开辟了一段临时空间，当把结构体变量当做实参传进函数时，实际上是把结构体变量中的结构体成员在函数中复制了一份，函数运行时操作的只不过是函数临时开辟空间中存放的结构体成员变量，并没有操作到原来的结构体中的结构体成员变量。当函数运行结束后，开辟的临时空间将会销毁，在函数中对结构体成员变量的操作结果也被销毁，此时传进的结构体变量 st 并没有用到，那么他输出的是没有赋初值的结构体变量，里面是内存中的一些垃圾数据。</p><p>2、要想对结构体成员变量进行操作需实参要穿进结构体变量的首地址，形参为结构体变量的指针用于接收实参传进来的结构体变量的首地址，通过地址我们可以找到结构体成员变量然后进行修改。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> age;<span class="comment">//4个字节</span></span><br><span class="line"><span class="keyword">char</span> sex;<span class="comment">//1个字节</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];<span class="comment">//100字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InpoutStudentInfo</span><span class="params">(struct Student * pstu)</span></span>;<span class="comment">//前置声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span>;</span></span><br><span class="line"><span class="comment">//pritnf(&quot;%d&quot;,sizeof(st));</span></span><br><span class="line"><span class="built_in">InpoutStudentInfo</span>(&amp;st);<span class="comment">//对结构体变量的输入</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;分数: %d 性别: %c 姓名: %s\n&quot;</span>,st.age,st.sex,st.name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InpoutStudentInfo</span><span class="params">(struct Student * pstu)</span><span class="comment">//pstu占4个字节</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   pstu-&gt;age = <span class="number">10</span>;</span><br><span class="line">   <span class="built_in">strcpy</span>(pstu-&gt;name,<span class="string">&quot;张三&quot;</span>);<span class="comment">//不能写成stu.name=&quot;张三&quot;;不行</span></span><br><span class="line">   pstu-&gt;sex =<span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、当我们用函数仅用来输出结构体成员变量此时可以用结构体变量做实参，缺点是相当消耗空间，因为函数临时开辟的空间需要存的下传进来的结构体变量。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> age;<span class="comment">//4个字节</span></span><br><span class="line"><span class="keyword">char</span> sex;<span class="comment">//1个字节</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];<span class="comment">//100字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InpoutStudentInfo</span><span class="params">(struct Student * pstu)</span></span>;<span class="comment">//前置声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutpoutStudentInfo</span><span class="params">(struct Student stu)</span></span>;<span class="comment">//对结构体变量的输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span>;</span></span><br><span class="line"><span class="comment">//pritnf(&quot;%d&quot;,sizeof(st));</span></span><br><span class="line"><span class="built_in">InpoutStudentInfo</span>(&amp;st);<span class="comment">//对结构体变量的输入</span></span><br><span class="line"><span class="built_in">OutpoutStudentInfo</span>(st);<span class="comment">//对结构体变量的输出不建议用因为传进的参数太占空间了参数st总共占了105个字节</span></span><br><span class="line">    <span class="comment">//机器对齐填充数据组成原理中的知识导致108个字节</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InpoutStudentInfo</span><span class="params">(struct Student * pstu)</span><span class="comment">//pstu占4个字节</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   pstu-&gt;age = <span class="number">10</span>;</span><br><span class="line">   <span class="built_in">strcpy</span>(pstu-&gt;name,<span class="string">&quot;张三&quot;</span>);<span class="comment">//不能写成stu.name=&quot;张三&quot;;不行</span></span><br><span class="line">   pstu-&gt;sex =<span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutpoutStudentInfo</span><span class="params">(struct Student st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;函数临时开辟的空间大小为%d个字节\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(st));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;分数: %d 性别: %c 姓名: %s\n&quot;</span>,st.age,st.sex,st.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时发现输出结构体的函数需要开辟一个能存放结构体中所有的成员的内存空间，这样想到耗内存，而且运行慢。</p><p>4、为了减小内存开销，使运行更快我们输出结构体成员变量时实参为结构体的变量，形参为结构体变量的指针接收结构体变量的地址。优点是内存开销较小，运行快，缺点：不安全，因为在输出函数中可以对结构体的成员变量进行修改（但是我们可以用 const 来修饰形参避免对结构体的成员变量的修改）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> age;<span class="comment">//4个字节</span></span><br><span class="line"><span class="keyword">char</span> sex;<span class="comment">//1个字节</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];<span class="comment">//100字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InpoutStudentInfo</span><span class="params">(struct Student * pstu)</span></span>;<span class="comment">//前置声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutpoutStudentInfo</span><span class="params">(struct Student * stu)</span></span>;<span class="comment">//对结构体变量的输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span>;</span></span><br><span class="line"><span class="comment">//pritnf(&quot;%d&quot;,sizeof(st));</span></span><br><span class="line"><span class="built_in">InpoutStudentInfo</span>(&amp;st);<span class="comment">//对结构体变量的输入</span></span><br><span class="line"><span class="built_in">OutpoutStudentInfo</span>(&amp;st);<span class="comment">//对结构体变量的输出建议用因为参数只传进一个结构体变量的首地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InpoutStudentInfo</span><span class="params">(struct Student * pstu)</span><span class="comment">//pstu占4个字节</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   pstu-&gt;age = <span class="number">10</span>;</span><br><span class="line">   <span class="built_in">strcpy</span>(pstu-&gt;name,<span class="string">&quot;张三&quot;</span>);<span class="comment">//不能写成stu.name=&quot;张三&quot;;不行</span></span><br><span class="line">   pstu-&gt;sex =<span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutpoutStudentInfo</span><span class="params">(struct Student * st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;函数临时开辟的空间大小为%d个字节\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(&amp;st));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;函数临时开辟的空间大小为%d个字节\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(st));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;分数: %d 性别: %c 姓名: %s\n&quot;</span>,st-&gt;age,(*st).sex,st-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、指针变量存放的是变量的首地址的详解</p><p>任何类型的指针变量系统只分配四个字节，指针变量存放的是变量的首地值，例如数组的首地值，结构体变量的首地值，double 类型数据的首地值，任何类型数据的首地地址；首地值即是数据第一个字节的地址编号，每一个字节的地址编号都是 32 位的二进制，这 32 位的地址编号占四个字节，所以系统为指针变量分配四个字节来存储首地值。然后系统会根据不同类型数据的首地址用不同的寻址方式找到数据。<br><img src="/images/6.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大帅哥张茂桃的小女朋友</title>
      <link href="post/7589.html"/>
      <url>post/7589.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/handsomeson/1.gif" alt="大帅哥"><br><img src="/images/handsomeson/3.jpg" width="600px" /></p><h3 id="乘风破浪懒羊羊就是我"><a class="header-anchor" href="#乘风破浪懒羊羊就是我">¶</a>乘风破浪懒羊羊就是我</h3><h4 id="天不生我张茂桃，帅道万古如长夜"><a class="header-anchor" href="#天不生我张茂桃，帅道万古如长夜">¶</a>天不生我张茂桃，帅道万古如长夜</h4><h4 id="诶-你没看见吗，当我拿出这张照片后太阳更辣了，小草更绿了，花儿更红了，就连小鸟也更欢喜了耶"><a class="header-anchor" href="#诶-你没看见吗，当我拿出这张照片后太阳更辣了，小草更绿了，花儿更红了，就连小鸟也更欢喜了耶">¶</a>诶~ 你没看见吗，当我拿出这张照片后太阳更辣了，小草更绿了，花儿更红了，就连小鸟也更欢喜了耶~~</h4><h4 id="上学时，老师讲到“帅”的含义我百思不得其解，这时同学递过来一面镜子我一照，刹那间我明白了。"><a class="header-anchor" href="#上学时，老师讲到“帅”的含义我百思不得其解，这时同学递过来一面镜子我一照，刹那间我明白了。">¶</a>上学时，老师讲到“帅”的含义我百思不得其解，这时同学递过来一面镜子我一照，刹那间我明白了。</h4><h4 id="有一天，我上街，突然一群人把我围住。指着说我帅，我说我不帅，他们就打我，还说我虚伪。"><a class="header-anchor" href="#有一天，我上街，突然一群人把我围住。指着说我帅，我说我不帅，他们就打我，还说我虚伪。">¶</a>有一天，我上街，突然一群人把我围住。指着说我帅，我说我不帅，他们就打我，还说我虚伪。</h4><h4 id="啦啦啦，人见人爱，鸟见鸟呆，风靡万千少女，刺激帅哥市场，挽救无数失足少年，一支梨花压海棠…"><a class="header-anchor" href="#啦啦啦，人见人爱，鸟见鸟呆，风靡万千少女，刺激帅哥市场，挽救无数失足少年，一支梨花压海棠…">¶</a>啦啦啦，人见人爱，鸟见鸟呆，风靡万千少女，刺激帅哥市场，挽救无数失足少年，一支梨花压海棠…</h4><h4 id="最富有才华，英俊潇洒。玉树临风。风流倜傥。高大威猛。人称：山崩地裂，水倒流，鬼见愁，美貌与智慧结合，英雄与侠义化身，人见人爱，花见花开，车见车爆胎"><a class="header-anchor" href="#最富有才华，英俊潇洒。玉树临风。风流倜傥。高大威猛。人称：山崩地裂，水倒流，鬼见愁，美貌与智慧结合，英雄与侠义化身，人见人爱，花见花开，车见车爆胎">¶</a>最富有才华，英俊潇洒。玉树临风。风流倜傥。高大威猛。人称：山崩地裂，水倒流，鬼见愁，美貌与智慧结合，英雄与侠义化身，人见人爱，花见花开，车见车爆胎~</h4><h4 id="一个不帅男人的标志是他愿意为自己的不帅英勇地死去，一个帅男人的标志是他愿意为自己的帅而卑贱地活着，所以，至今我还为自己的帅坚强的活着。"><a class="header-anchor" href="#一个不帅男人的标志是他愿意为自己的不帅英勇地死去，一个帅男人的标志是他愿意为自己的帅而卑贱地活着，所以，至今我还为自己的帅坚强的活着。">¶</a>一个不帅男人的标志是他愿意为自己的不帅英勇地死去，一个帅男人的标志是他愿意为自己的帅而卑贱地活着，所以，至今我还为自己的帅坚强的活着。</h4><h4 id="后记-我死后我千万年，后人类诞生，他们将我的骸骨还原，葬在北极，在我的墓碑上空，终年漂浮着一片云彩，变幻来变幻去，只有一个字-帅…"><a class="header-anchor" href="#后记-我死后我千万年，后人类诞生，他们将我的骸骨还原，葬在北极，在我的墓碑上空，终年漂浮着一片云彩，变幻来变幻去，只有一个字-帅…">¶</a>后记:我死后我千万年，后人类诞生，他们将我的骸骨还原，葬在北极，在我的墓碑上空，终年漂浮着一片云彩，变幻来变幻去，只有一个字:帅…</h4><h4 id="帅不仅仅是男人的痛苦，也是女人的痛苦…我孤老终身…因为…所有的-MM-都自认为配不上我…帅人从不说自己帅，帅人要抓紧时间作帅的样子。"><a class="header-anchor" href="#帅不仅仅是男人的痛苦，也是女人的痛苦…我孤老终身…因为…所有的-MM-都自认为配不上我…帅人从不说自己帅，帅人要抓紧时间作帅的样子。">¶</a>帅不仅仅是男人的痛苦，也是女人的痛苦…我孤老终身…因为…所有的 MM 都自认为配不上我…帅人从不说自己帅，帅人要抓紧时间作帅的样子。</h4><h4 id="帅到，走在街上开车的人看了都会发生交通事故，汽车追尾；路人看了都有迷倒晕倒"><a class="header-anchor" href="#帅到，走在街上开车的人看了都会发生交通事故，汽车追尾；路人看了都有迷倒晕倒">¶</a>帅到，走在街上开车的人看了都会发生交通事故，汽车追尾；路人看了都有迷倒晕倒~~</h4><p><img src="/images/handsomeson/1.gif" alt="大帅哥"></p><!-- <img src="/images/handsomeson/1.jpg" width="300px" /><img src="/images/handsomeson/2.jpg" width="300px" /> --><div class="justified-gallery"><p><img src="https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/gEy5Zc1Ai6VuO4N.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/d6QHbytlSYO4FBG.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/6nepIJ1xTgufatZ.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/E7Jvr4eIPwUNmzq.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/mh19anwBSWIkGlH.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/2tu9JC8ewpBFagv.jpg" alt=""></p>          </div><!-- <div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img" src='https://i.loli.net/2019/11/10/T7Mu8Aod3egmC4Q.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">壁紙</div>  <p>收藏的一些壁紙</p>  <a href='/Gallery/wallpaper'></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img" src='https://i.loli.net/2019/12/25/8t97aVlp4hgyBGu.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">漫威</div>  <p>關於漫威的圖片</p>  <a href='/Gallery/marvel'></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img" src='https://i.loli.net/2019/12/25/hOqbQ3BIwa6KWpo.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">OH MY GIRL</div>  <p>關於OH MY GIRL的圖片</p>  <a href='/Gallery/ohmygirl'></a>  </figcaption>  </figure>  </div> -->]]></content>
      
      
      <categories>
          
          <category> 非人类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 畜生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表的实现</title>
      <link href="post/1c56.html"/>
      <url>post/1c56.html</url>
      
        <content type="html"><![CDATA[<h3 id="单链表"><a class="header-anchor" href="#单链表">¶</a>单链表</h3><ul><li>删除插入结点到指定的 i 位置时要先获取第 i-1 个结点，插入不用判断第 i 个结点是否存在，删除需要判断第 i 个结点是否存在；</li><li>头插法再循环外定义头结点的 next 域为 nullptr，尾插法在循环结束后将最后一个结点的指针域设为 nullptr；</li><li>切记在调用函数时不要传参传错位置 😢 😭 😿 害我找了半天啊~ 💢 💢 💢</li></ul><h4 id="没注释的代码"><a class="header-anchor" href="#没注释的代码">¶</a>没注释的代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">DataType data;</span><br><span class="line">Node&lt;DataType&gt;* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">LinkList</span>();</span><br><span class="line"><span class="built_in">LinkList</span>(DataType a[], <span class="keyword">int</span> e);</span><br><span class="line">~<span class="built_in">LinkList</span>();</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">()</span></span>;<span class="comment">//求单链表长度</span></span><br><span class="line"><span class="function">DataType <span class="title">Get</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Locate</span><span class="params">(DataType x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> i, DataType x)</span></span>;</span><br><span class="line"><span class="function">DataType <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node&lt;DataType&gt;* first;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">LinkList&lt;DataType&gt;::<span class="built_in">LinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">first = <span class="keyword">new</span> Node;</span><br><span class="line">first-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">LinkList&lt;DataType&gt;::<span class="built_in">LinkList</span>(DataType a[], <span class="keyword">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line">first = <span class="keyword">new</span> Node&lt;DataType&gt;;</span><br><span class="line">Node&lt;DataType&gt;* p = first, * s = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line">s = <span class="keyword">new</span> Node&lt;DataType&gt;;</span><br><span class="line">s-&gt;data = a[i];</span><br><span class="line">p-&gt;next = s;</span><br><span class="line">p = s;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//first = new Node&lt;DataType&gt;;</span></span><br><span class="line"><span class="comment">//Node&lt;DataType&gt;* s = nullptr;</span></span><br><span class="line"><span class="comment">//first-&gt;next = nullptr;</span></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; e; i++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">////头插法</span></span><br><span class="line"><span class="comment">//s = new Node&lt;DataType&gt;;</span></span><br><span class="line"><span class="comment">//s-&gt;data = a[i];</span></span><br><span class="line"><span class="comment">//s-&gt;next = first-&gt;next;</span></span><br><span class="line"><span class="comment">//first-&gt;next = s;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">LinkList&lt;DataType&gt;::~<span class="built_in">LinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;DataType&gt;* s = first;</span><br><span class="line"><span class="keyword">while</span> (first != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">first = first-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> s;</span><br><span class="line">s = first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">int</span> LinkList&lt;DataType&gt;::<span class="built_in">Length</span>() &#123;</span><br><span class="line">Node&lt;DataType&gt;* p = first-&gt;next;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">DataType LinkList&lt;DataType&gt;::<span class="built_in">Get</span>(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">DataType x;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">Node&lt;DataType&gt;* p = first;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != <span class="literal">nullptr</span> &amp;&amp; count &lt; i)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">x = p-&gt;data;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">int</span> LinkList&lt;DataType&gt;::<span class="built_in">Locate</span>(DataType x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">Node&lt;DataType&gt;* p = first;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;data == x)</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">void</span> LinkList&lt;DataType&gt;::<span class="built_in">Insert</span>(<span class="keyword">int</span> i, DataType x)</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;DataType&gt;* p = first, * s = <span class="literal">nullptr</span>; <span class="comment">//工作指针p初始化</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; count &lt; i - <span class="number">1</span>)  <span class="comment">//查找第i – 1个结点</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next; <span class="comment">//工作指针p后移</span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span><span class="string">&quot;位置错误&quot;</span>; <span class="comment">//没有找到第i – 1个结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">s = <span class="keyword">new</span> Node&lt;DataType&gt;;</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">DataType LinkList&lt;DataType&gt;::<span class="built_in">Delete</span>(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">DataType x;</span><br><span class="line">Node&lt;DataType&gt;* p = first, * r = <span class="literal">nullptr</span>;   <span class="comment">//工作指针p指向头结点</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; count &lt; i - <span class="number">1</span>) <span class="comment">//查找第i-1个结点</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">nullptr</span> || p-&gt;next == <span class="literal">nullptr</span>)<span class="comment">//结点p不存在或p的后继结点不存在</span></span><br><span class="line"><span class="keyword">throw</span><span class="string">&quot;位置错误&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">r = p-&gt;next;</span><br><span class="line">x = r-&gt;data;</span><br><span class="line">p-&gt;next = r-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">bool</span> LinkList&lt;DataType&gt;::<span class="built_in">Empty</span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (first-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">void</span> LinkList&lt;DataType&gt;::<span class="built_in">PrintList</span>()</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;DataType&gt;* p = first-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;, i, x;</span><br><span class="line">LinkList&lt;<span class="keyword">int</span>&gt; L&#123; r, <span class="number">5</span> &#125;;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前线性表的数据为：&quot;</span>;</span><br><span class="line">L.<span class="built_in">PrintList</span>();                         <span class="comment">//输出当前链表1 2 3 4 5</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">L.<span class="built_in">Insert</span>(<span class="number">2</span>, <span class="number">8</span>);                         <span class="comment">//在第2个位置插入值为8的结点</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;执行插入操作后数据为：&quot;</span>;</span><br><span class="line">L.<span class="built_in">PrintList</span>();                         <span class="comment">//输出插入后链表1 8 2 3 4 5</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">char</span>* str) &#123;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前单链表的长度为：&quot;</span> &lt;&lt; L.<span class="built_in">Length</span>() &lt;&lt; endl;      <span class="comment">//输出单链表长度6</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入查找的元素值：&quot;</span>;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">i = L.<span class="built_in">Locate</span>(x);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> &lt;= i) cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;的元素位置为：&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;单链表中没有元素&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入要删除第几个元素：&quot;</span>;</span><br><span class="line">cin &gt;&gt; i;</span><br><span class="line">x = L.<span class="built_in">Delete</span>(i);                                 <span class="comment">//删除第i个元素</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;删除的元素值是&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;执行删除操作后数据为：&quot;</span>;</span><br><span class="line">L.<span class="built_in">PrintList</span>();                                 <span class="comment">//输出删除后链表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">char</span>* str) &#123;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有注释的代码"><a class="header-anchor" href="#有注释的代码">¶</a>有注释的代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>                  <span class="comment">//引入输入输出流</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DataType data;               <span class="comment">//数据域</span></span><br><span class="line">    Node&lt;DataType&gt;* next;       <span class="comment">//指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkList</span>();                      <span class="comment">//无参构造函数，建立只有头结点的空链表</span></span><br><span class="line">    <span class="built_in">LinkList</span>(DataType a[], <span class="keyword">int</span> n);       <span class="comment">//有参构造函数，建立有n个元素的单链表</span></span><br><span class="line">    ~<span class="built_in">LinkList</span>();                     <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">()</span></span>;                     <span class="comment">//求单链表的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Empety</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">DataType <span class="title">Get</span><span class="params">(<span class="keyword">int</span> i)</span></span>;               <span class="comment">//按位查找。查找第i个结点的元素值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Locate</span><span class="params">(DataType x)</span></span>;            <span class="comment">//按值查找。查找值为x的元素序号</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> i, DataType x)</span></span>;       <span class="comment">//插入操作，第i个位置插入值为x的结点</span></span><br><span class="line">    <span class="function">DataType <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> i)</span></span>;            <span class="comment">//删除操作，删除第i个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">()</span></span>;                  <span class="comment">//遍历操作，按序号依次输出各元素</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;DataType&gt;* first;           <span class="comment">//单链表的头指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">LinkList&lt;DataType&gt; ::<span class="built_in">LinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    first = <span class="keyword">new</span> Node&lt;DataType&gt;;              <span class="comment">//生成头结点</span></span><br><span class="line">    first-&gt;next = <span class="literal">nullptr</span>;                      <span class="comment">//头结点的指针域置空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">DataType</span>&gt;</span></span><br><span class="line">LinkList&lt;DataType&gt; :: ~<span class="built_in">LinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;DataType&gt;* q = first;       <span class="comment">//暂存被释放结点</span></span><br><span class="line">    <span class="keyword">while</span> (first != <span class="literal">nullptr</span>)        <span class="comment">//释放单链表的每一个结点的存储空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// q = first;</span></span><br><span class="line">        first = first-&gt;next;         <span class="comment">// first指向被释放结点的下一个结点</span></span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">        q = first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">int</span> LinkList&lt;DataType&gt; ::<span class="built_in">Empety</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (first-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">void</span> LinkList&lt;DataType&gt; ::<span class="built_in">PrintList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;DataType&gt;* p = first-&gt;next;                <span class="comment">//工作指针p初始化</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        p = p-&gt;next;                 <span class="comment">//工作指针p后移，注意不能写作p++</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">int</span> LinkList&lt;DataType&gt; ::<span class="built_in">Length</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;DataType&gt;* p = first-&gt;next;   <span class="comment">//工作指针p初始化为开始接点</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;                    <span class="comment">//累加器count初始化</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;              <span class="comment">//注意count的初始化和返回值之间的关系</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">DataType LinkList&lt;DataType&gt; ::<span class="built_in">Get</span>(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;DataType&gt;* p = first-&gt;next;    <span class="comment">//工作指针p初始化</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;                     <span class="comment">//累加器count初始化</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; count &lt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;                   <span class="comment">//工作指针p后移</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="keyword">throw</span> <span class="string">&quot;位置&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">int</span> LinkList&lt;DataType&gt; ::<span class="built_in">Locate</span>(DataType x)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;DataType&gt;* p = first-&gt;next;   <span class="comment">//工作指针p初始化</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;                     <span class="comment">//累加器count初始化</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == x) <span class="keyword">return</span> count;     <span class="comment">//查找成功，结束函数并返回序号</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                        <span class="comment">//退出循环表明查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">void</span> LinkList&lt;DataType&gt; ::<span class="built_in">Insert</span>(<span class="keyword">int</span> i, DataType x)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;DataType&gt;* p = first, * s = <span class="literal">nullptr</span>;        <span class="comment">//工作指针p初始化</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; count &lt; i - <span class="number">1</span>)            <span class="comment">//查找第i – 1个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;                              <span class="comment">//工作指针p后移</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="keyword">throw</span> <span class="string">&quot;位置&quot;</span>;        <span class="comment">//没有找到第i – 1个结点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        s = <span class="keyword">new</span> Node&lt;DataType&gt;; s-&gt;data = x;      <span class="comment">//申请结点s，数据域为x</span></span><br><span class="line">        s-&gt;next = p-&gt;next; p-&gt;next = s;     <span class="comment">//将结点s插入到结点p之后</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头插法构造</span></span><br><span class="line"><span class="comment">//template &lt;typename DataType&gt;</span></span><br><span class="line"><span class="comment">//LinkList&lt;DataType&gt; :: LinkList(DataType a[ ], int n)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//first = new Node&lt;DataType&gt;; first-&gt;next = nullptr;     //初始化一个空链表</span></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; n; i++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//Node&lt;DataType&gt; *s;</span></span><br><span class="line"><span class="comment">//s = new Node&lt;DataType&gt;; s-&gt;data = a[i];</span></span><br><span class="line"><span class="comment">// s-&gt;next = first-&gt;next; first-&gt;next = s;    //将结点s插入到头结点之后</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">LinkList&lt;DataType&gt; ::<span class="built_in">LinkList</span>(DataType a[], <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    first = <span class="keyword">new</span> Node&lt;DataType&gt;;                    <span class="comment">//生成头结点</span></span><br><span class="line">    Node&lt;DataType&gt;* r = first, * s = <span class="literal">nullptr</span>;           <span class="comment">//尾指针初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s = <span class="keyword">new</span> Node&lt;DataType&gt;;</span><br><span class="line">        s-&gt;data = a[i];</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;                 <span class="comment">//将结点s插入到终端结点之后</span></span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">nullptr</span>;        <span class="comment">//单链表建立完毕，将终端结点的指针域置空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template &lt;typename DataType&gt;</span></span><br><span class="line"><span class="comment">LinkList&lt;DataType&gt; ::LinkList(DataType a[], int n)//头插法</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    first = new Node&lt;DataType&gt;;                    //生成头结点</span></span><br><span class="line"><span class="comment">    Node&lt;DataType&gt;* r = first, * s = nullptr;           //尾指针初始化</span></span><br><span class="line"><span class="comment">    r-&gt;next = NULL;</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; n; i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        s = new Node&lt;DataType&gt;;</span></span><br><span class="line"><span class="comment">        s-&gt;data = a[i];</span></span><br><span class="line"><span class="comment">        s-&gt;next = r-&gt;next;</span></span><br><span class="line"><span class="comment">        r-&gt;next = s;</span></span><br><span class="line"><span class="comment">                         //将结点s插入到终端结点之后</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  //  r-&gt;next = nullptr;        //单链表建立完毕，将终端结点的指针域置空</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">DataType LinkList&lt;DataType&gt; ::<span class="built_in">Delete</span>(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    DataType x;</span><br><span class="line">    Node&lt;DataType&gt;* p = first, * q = <span class="literal">nullptr</span>;        <span class="comment">//工作指针p指向头结点</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; count &lt; i - <span class="number">1</span>)           <span class="comment">//查找第i-1个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || p-&gt;next == <span class="literal">nullptr</span>)  <span class="comment">//结点p不存在或p的后继结点不存在</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;位置错误&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        q = p-&gt;next; x = q-&gt;data;         <span class="comment">//暂存被删结点</span></span><br><span class="line">        p-&gt;next = q-&gt;next;              <span class="comment">//摘链</span></span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;, i, x;</span><br><span class="line">    LinkList&lt;<span class="keyword">int</span>&gt; L&#123; r, <span class="number">5</span> &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;当前线性表的数据为：&quot;</span>;</span><br><span class="line">    L.<span class="built_in">PrintList</span>();                         <span class="comment">//输出当前链表1 2 3 4 5</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        L.<span class="built_in">Insert</span>(<span class="number">2</span>, <span class="number">8</span>);                         <span class="comment">//在第2个位置插入值为8的结点</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;执行插入操作后数据为：&quot;</span>;</span><br><span class="line">        L.<span class="built_in">PrintList</span>();                         <span class="comment">//输出插入后链表1 8 2 3 4 5</span></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">char</span>* str) &#123;</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;当前单链表的长度为：&quot;</span> &lt;&lt; L.<span class="built_in">Length</span>() &lt;&lt; endl;      <span class="comment">//输出单链表长度6</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入查找的元素值：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    i = L.<span class="built_in">Locate</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> &lt;= i) cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;的元素位置为：&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;单链表中没有元素&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入要删除第几个元素：&quot;</span>;</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">        x = L.<span class="built_in">Delete</span>(i);                                 <span class="comment">//删除第i个元素</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;删除的元素值是&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;执行删除操作后数据为：&quot;</span>;</span><br><span class="line">        L.<span class="built_in">PrintList</span>();                                 <span class="comment">//输出删除后链表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">char</span>* str) &#123;</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTMl5 新增标签</title>
      <link href="post/90a4.html"/>
      <url>post/90a4.html</url>
      
        <content type="html"><![CDATA[<h3 id="web-前端：main、header、footer、nav、article、section-标签的用法"><a class="header-anchor" href="#web-前端：main、header、footer、nav、article、section-标签的用法">¶</a>web 前端：main、header、footer、nav、article、section 标签的用法</h3><hr><blockquote><p>HTML5<br>添加了诸如 main、header、footer、nav、article、section 等大量新标签，这些新标签为开发人员提供更多的选择和辅助特性。<br>默认情况下，浏览器呈现这些新标签的方式与 div 相似。然而，合理地使用它们，可以使你的标签更加的语义化。辅助技术（如：屏幕阅读器）可以通过这&gt; 些标签为用户提供更加准确的、易于理解的页面信息。</p></blockquote><h4 id="标签-main"><a class="header-anchor" href="#标签-main">¶</a><strong>标签 main</strong></h4><p>​ main 标签用于呈现网页的主体内容，且每个页面只能有一个。这意味着它只应包含与页面中心主题相关的信息，而不应包含如导航连接、网页横幅等可以在多个页面中重复出现的内容。main 标签的语义化特性可以使辅助技术快速定位到页面的主体。有些页面中有 “跳转到主要内容” 的链接，使用 main 标签可以使辅助设备自动获得这个功能。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Weapons of the Ninja<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span>//网页的主体内容<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">//main标签应该在header标签与footer标签之间。</span><br></pre></td></tr></table></figure><h4 id="标签-article"><a class="header-anchor" href="#标签-article">¶</a><strong>标签 article</strong></h4><p>​ article 是另一个具有语义化特性的 HTML5 新标签。article 是一个分段标签，用于呈现独立及完整的内容。这个标签适用于博客入口、论坛帖子或者新闻文。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Deep Thoughts with Master Camper Cat<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>The Garfield Files: Lasagna as Training Fuel?<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">The internet is littered with varying opinions on nutritional</span><br><span class="line">paradigms, from catnip paleo to hairball cleanses. But let&#x27;s turn</span><br><span class="line">our attention to an often overlooked fitness fuel, and examine the</span><br><span class="line">protein-carb-NOM trifecta that is lasagna...</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">//用于呈现独立及完整的内容</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;samuraiSwords.jpeg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Defeating your Foe: the Red Dot is Ours!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">Felines the world over have been waging war on the most persistent</span><br><span class="line">of foes. This red nemesis combines both cunning stealth and</span><br><span class="line">lightening speed. But chin up, fellow fighters, our time for victory</span><br><span class="line">may soon be near...</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;samuraiSwords.jpeg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Is Chuck Norris a Cat Person?<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">Chuck Norris is widely regarded as the premier martial artist on the</span><br><span class="line">planet, and it&#x27;s a complete coincidence anyone who disagrees with</span><br><span class="line">this fact mysteriously disappears soon after. But the real question</span><br><span class="line">is, is he a cat person?...</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="请注意-section-和-div-的区别："><a class="header-anchor" href="#请注意-section-和-div-的区别：">¶</a><strong>请注意 section 和 div 的区别：</strong></h5><p>​ section 也是一个 HTML5 新标签，与 article 标签的语义含义略有不同。article 用于独立的、完整的内容，而 section 用于对与主题相关的内容进行分组。它们可以根据需要嵌套着使用。举个例子：如果一本书是一个 article 的话，那么每个章节就是 section。当内容组之间没有联系时，可以使用 div。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">- 内容组</span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">- 有联系的内容组</span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span>- 独立完整的内容<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="标签-header"><a class="header-anchor" href="#标签-header">¶</a><strong>标签 header</strong></h4><p>header 也是一个具有语义化的、提升页面可访问性的 HTML5 标签。它可以为父级标签呈现简介信息或者导航链接，适用于那些在多个页面顶部重复出现的内容。</p><p>与 main 类似，header 的语义化特性也可以使辅助技术快速定位到它的内容。</p><h5 id="注意：-header-用在-HTML-文档的-body-标签中。这点与包含页面标题、元信息的-head-标签不同。"><a class="header-anchor" href="#注意：-header-用在-HTML-文档的-body-标签中。这点与包含页面标题、元信息的-head-标签不同。">¶</a><strong>注意</strong>： header 用在 HTML 文档的 body 标签中。这点与包含页面标题、元信息的 head 标签不同。</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Training with Camper Cat<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">//适用于那些在多个页面顶部重复出现的内容，导航或简介信息</span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;stealth&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Stealth <span class="symbol">&amp;amp;</span> Agility Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><br><span class="line">Climb foliage quickly using a minimum spanning tree approach</span><br><span class="line"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>No training is NP-complete without parkour<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;combat&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Combat Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Dispatch multiple enemies with multithreaded tactics<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Goodbye world: 5 proven ways to knock out an opponent<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;weapons&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Weapons Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Swords: the best tool to literally divide and conquer<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Breadth-first or depth-first in multi-weapon training?<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="标签-nav"><a class="header-anchor" href="#标签-nav">¶</a><strong>标签 nav</strong></h4><p>nav 也是一个具有语义化特性的 HTML5 标签，用于呈现页面中的主导航链接。它可以使屏幕阅读器快速识别页面中的导航信息。对于页面底部辅助性质的站点链接，不需要使用 nav，用 footer 会更好。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Training with Camper Cat<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#stealth&quot;</span>&gt;</span>Stealth <span class="symbol">&amp;amp;</span> Agility<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#combat&quot;</span>&gt;</span>Combat<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#weapons&quot;</span>&gt;</span>Weapons<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">//用于呈现页面中的主导航链接</span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;stealth&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Stealth <span class="symbol">&amp;amp;</span> Agility Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><br><span class="line">Climb foliage quickly using a minimum spanning tree approach</span><br><span class="line"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>No training is NP-complete without parkour<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;combat&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Combat Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Dispatch multiple enemies with multithreaded tactics<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Goodbye world: 5 proven ways to knock out an opponent<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;weapons&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Weapons Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Swords: the best tool to literally divide and conquer<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Breadth-first or depth-first in multi-weapon training?<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="标签-footer"><a class="header-anchor" href="#标签-footer">¶</a><strong>标签 footer</strong></h4><p>​ 与 header 和 nav 类似，footer 也具有语义化特性，可以使辅助设备快速定位到它。它位于页面底部，用于呈现版权信息或者相关文档链接。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Training<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#stealth&quot;</span>&gt;</span>Stealth <span class="symbol">&amp;amp;</span> Agility<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#combat&quot;</span>&gt;</span>Combat<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#weapons&quot;</span>&gt;</span>Weapons<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;stealth&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Stealth <span class="symbol">&amp;amp;</span> Agility Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><br><span class="line">Climb foliage quickly using a minimum spanning tree approach</span><br><span class="line"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>No training is NP-complete without parkour<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;combat&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Combat Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Dispatch multiple enemies with multithreaded tactics<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Goodbye world: 5 proven ways to knock out an opponent<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;weapons&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Weapons Training<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Swords: the best tool to literally divide and conquer<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Breadth-first or depth-first in multi-weapon training?<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="symbol">&amp;copy;</span> 2016 Camper Cat<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">//用于呈现版权信息或者相关文档链接</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
